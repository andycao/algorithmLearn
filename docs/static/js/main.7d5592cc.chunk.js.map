{"version":3,"sources":["pages/header.js","leetcode_js/myAtoi_leetcode08.js","leetcode_js/flatten.js","leetcode_js/longestPalindrome.js","leetcode_js/reverseLinkedList.js","leetcode_js/mirrorTree101.js","leetcode_js/candies2.js","leetcode_js/findContinuousSequence.js","leetcode_js/preorderTraversal.js","leetcode_js/maxProfit.js","leetcode_js/isSameTree.js","leetcode_js/diameterOfBinaryTree.js","leetcode_js/canThreePartsEqualSum.js","leetcode_js/gcdOfStrings.js","leetcode_js/majorityElement.js","leetcode_js/compressString.js","leetcode_js/countChars.js","leetcode_js/isRectangleOverlap.js","leetcode_js/maxDepth.js","pages/list.js","App.js","serviceWorker.js","index.js"],"names":["Header","res","str","s","trim","exec","num","parseInt","myAtoi","console","log","flatten","array","reduce","acc","val","concat","Array","isArray","findLongestAround","left","right","length","charAt","out","i","len1","len2","len","Math","max","substr","floor","longestPalindrome","reverseList","head","newHead","temp","next","reverse","pre","cur","ListNode","this","h1","old","JSON","stringify","newH","TreeNode","root","list","a","shift","b","push","isSymmetric","candies","num_people","fill","distributeCandies","target","result","l","r","sum","mid","ceil","index","findContinuousSequence","preorderTraversal","node","pop","prices","minPrice","v","maxProfit","root1","root2","isSameTree","p","q","maxRadius","findDepth","leftDepth","rightDepth","diameterOfBinaryTree","j","A","canThreePartsEqualSum","isGcd","x","RegExp","test","gcd","num1","num2","tmp","str1","str2","gcdNum","gcdOfStrings","nums","lists","Map","maxNum","maxEl","e","has","set","get","majorityElement","func","S","compressString","title","parseWordToMap","map","map1","map2","keys","k","words","chars","known","total","word","countCharacters","isRangeOverlap","rec1","rec2","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","isRectangleOverlap","maxDepth","leetLink","file","urlPrefix","Link","props","name","className","onClick","window","open","source","TaskList","useState","setResult","atoi","reverseLinkedList","mirrorTree101","candies2","App","React","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7d5592cc.chunk.js","sourcesContent":["import React from 'react';\nfunction Header() {\n    return (\n        <div>\n            <h2>算法学习记录</h2>\n            <p>点击查看执行结果，console</p>\n            <hr></hr>\n        </div>\n    );\n}\n\nexport default Header;","/**\n * 8. 字符串转换整数 (atoi)\n * @param {string} str\n * @return {number}\n */\nlet max = 2147483648 - 1;\nlet min = -2147483648;\nvar myAtoi = function(str) {\n    let s = str.trim();\n\n    let reg = /^[+-]?\\d+/;\n    let res = reg.exec(s);\n    if(res) {\n        let num = parseInt(res[0]);\n        if(num > max) return max;\n        else if(num < min) return min;\n        else return num;\n    } else {\n        return 0;\n    }\n};\n\nexport default () => {\n    const res = myAtoi('-91283472332-=')\n    console.log(res);\n    return res;\n}\n\n","// const flatten = function (array) {\n//     let result = [];\n//     for(let e of array) {\n//         if(Array.isArray(e)) {\n//             result.push(...flatten(e))\n//         } else {\n//             result.push(e)\n//         }\n//     }\n//     return result;\n// }\n\nconst flatten = function (array) {\n    return array.reduce(\n        (acc, val) => acc.concat(Array.isArray(val) ? flatten(val) : val),\n        [])\n}\n\nexport default () => {\n    const res = flatten([1, 2, 3, [4, 5, 6, [7, 8]]])\n    console.log(res);\n    return res;\n}\n\n","/* eslint-disable no-unused-vars */\n/**\n * 5. 最长回文子串\n * 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n\n    let res = '';\n\n    for (let i = 0; i < s.length; i++) {\n        let len1 = findLongestAround(s, i, i); //奇数\n        let len2 = findLongestAround(s, i, i + 1) //偶数\n        let len = Math.max(len1, len2);\n        if(len > res.length) {\n            res = s.substr(i - Math.floor((len - 1) / 2), len);\n        }\n    }\n\n    return res;\n};\n\nfunction testPalindrome(str) {\n    let reverse = [...str].reverse().join('');\n    return reverse === str;\n}\n\nfunction testPal(str, i, j) {\n    while(i < j) {\n        if(str.charAt(i) !== str.charAt(j)){\n            return false\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n\nfunction findLongestAround(str, left, right) {\n\n    while (left >= 0 && right < str.length && str.charAt(left) === str.charAt(right)) {\n        left--;\n        right++;\n    }\n    return right - left - 1\n}\n\nconst longestPalindromeViolence = function (str) {\n    const len = str.length;\n    if(len < 2) {\n        return str;\n    }\n\n    let res = str.substr(0, 1);\n    for (let i = 0; i < len; i++) {\n        for(let j = i; j < len; j++) {\n            if(j - i + 1 > res.length && testPal(str, i, j)) {\n                res = str.substr(i, j - i + 1);\n            }\n        }\n    }\n\n    return res;\n}\n\nexport default () => {\n    let input = 'abcabcabcabccedabbac'\n    let out = longestPalindrome(input)\n    //输出 console\n    console.log(out);\n\n    //输出 obj 展示\n    return out;\n}","/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * 迭代的方法\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    let newHead = null;\n    let temp = head;\n    while (temp) {\n        temp = head.next;\n        head.next = newHead;\n        newHead = head;\n        head = temp;\n    }\n\n    return newHead;\n};\n\n\n/**\n * 递归的方法\n * 反向递归\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    if (head == null || head.next == null)\n        return head;\n\n    let res = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n\n    return res;\n};\n\nvar reverseList = (head) => {\n    // debugger\n    let reverse = (pre, cur) => {\n        if (!cur) return pre;\n        // 保存 next 节点\n        let next = cur.next;\n        cur.next = pre;\n        return reverse(cur, next);\n    }\n    return reverse(null, head);\n}\n\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nlet h1 = new ListNode(1);\nh1.next = new ListNode(2);\nh1.next.next = new ListNode(3);\nh1.next.next.next = new ListNode(4);\n\nexport default () => {\n    let old = JSON.stringify(h1);\n    let newH = reverseList(h1);\n    console.log('old', old);\n    console.log('new', newH);\n\n    return JSON.stringify(newH)\n}\n","/* eslint-disable no-redeclare */\n/**\n * 101 给定一个二叉树，检查它是否是镜像对称的。\n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n           1\n       /        \\\n     2           2\n   /   \\       /   \\\n  3     4     4     3\n / \\   / \\   / \\   / \\\n5   6 7   8 8   7 6   5\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/symmetric-tree\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 递归的方法，如果两个树是镜像树的话，那么他们的值相等，并且一个的左边，与另一个的右边互为镜像树\n * 一个的右边与另一个的左边互为镜像树\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n    return isMirror(root, root);\n};\n\nfunction isMirror(nodeLeft, nodeRight) {\n    if (nodeLeft === null && nodeRight === null) {\n        return true;\n    } else if (nodeLeft === null || nodeRight === null) {\n        return false;\n    } else if (nodeLeft.val === nodeRight.val &&\n        isMirror(nodeLeft.left, nodeRight.right) &&\n        isMirror(nodeLeft.right, nodeRight.left)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * 递归，除了root向队列里推左右两边，shift出来2个元素，比较相同。如果相等，继续推两个元素的左边，右边一对，右边，左边一对\n * 不相等时退出，两个元素同为null时退出\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n    if(root === null) return true;\n    let list = [root.left, root.right];\n    \n    while(list.length > 0) {\n        let a = list.shift();\n        let b = list.shift();\n\n        if(a === null && b == null) {\n            continue;\n        } else if(a === null || b === null) {\n            return false;\n        } else if(a.val === b.val) {\n            list.push(a.left, b.right);\n            list.push(a.right, b.left);\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(2);\nroot.left.left = new TreeNode(3);\nroot.right.right = new TreeNode(3);\nroot.left.right = new TreeNode(4);\nroot.right.left = new TreeNode(4);\n\nexport default () => {\n    let res = isSymmetric(root);\n    console.log(root, res);\n\n    return `isSymmetric ${res}`\n}\n\n\n","/**\n * 1103 分糖果2\n * 排排坐，分糖果。\n\n我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。\n\n给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。\n\n然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。\n\n重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。\n\n返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。\n\n \n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/distribute-candies-to-people\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n * 定义一个数组，数组长度n, 顺序给数组的值 +糖果数\n * @param {number} candies\n * @param {number} num_people\n * @return {number[]}\n */\nvar distributeCandies = function(candies, num_people) {\n    let array = new Array(num_people).fill(0);\n\n    let i = 0;\n    let num = 1;\n    while(candies > 0) {\n        if(num > candies) {\n            num = candies;\n        }\n        array[i] += num;\n        candies -= num;\n\n        num += 1;\n        i = ++i % num_people;\n    }\n\n    console.log(array);\n\n    return array;\n    \n};\n\nexport default () => {\n    const res = distributeCandies(16, 3)\n    console.log(res);\n    return JSON.stringify(res);\n}\n","/**\n * 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n示例 1：\n\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n示例 2：\n\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n \n\n限制：\n\n1 <= target <= 10^5\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n * 暴力的方法，1 ~ target / 2，每个数开始，加起来看看是否相等于target\n 小于则继续加，大于则不成立，等于则数组有效\n * @param {number} target\n * @return {number[][]}\n */\nvar findContinuousSequence = function(target) {\n    let result = [];\n    //1\n    if(target === 1) {\n        return result;\n    }\n\n    //从1 开始 到 Math.ceil(target / 2)\n    for(let i = 1; i < Math.ceil(target / 2); i++) {\n        let sum = 0;\n        let acc = i;\n        while(sum <= target) {\n            if(sum < target) {\n                sum += acc++;\n            } else if(sum === target){\n                //equal array from i ~ acc\n                let array = [];\n                for(let index = i; index < acc; index++) {\n                    array.push(index);\n                }\n\n                result.push(array);\n\n                break;\n            }\n        }\n    }\n\n    return result;\n};\n/*\n* 滑动窗口 \n定义左侧，右侧，l,r  1,2\n计算l ~ r 的和，< target l不变，r可以向右扩展\n= target 则l r组合正确，而且l开头的组合就这一个保存并且l + 1，r + 1。 \n    l+1 r 的组合肯定小于target。l最远能到target / 2中间\n>target 则l 开头没有正确组合， l + 1, r不变\n当l > target / 2 或l >= r时结束循环，返回结果\n\n* @param {number} target\n* @return {number[][]}\n*/\nvar findContinuousSequence = function(target) {\n    let result = [];\n    if(target === 1) return result;\n    let l = 1;\n    let r = 2;\n\n    let sum = 0;\n    let mid = Math.ceil(target / 2);\n    while(l < mid && l < r) {\n        sum = (l + r) * (r - l + 1) / 2;\n        if(sum < target) {\n            r++;\n        } else if(sum === target) {\n            let array = [];\n            for(let index = l; index <= r; index++) {\n                array.push(index);\n            }\n            result.push(array);\n\n            l++;\n            r++;\n        } else {\n            l++;\n        }\n    }\n\n    return result;\n}\n\nexport default () => {\n    const res = findContinuousSequence(15)\n    console.log(res);\n    return JSON.stringify(res);\n}\n","/**\n * 144.给定一个二叉树，返回它的 先序 遍历。\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 递归的方法，先访问本节点value，再访问左节点，再右节点\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n    let result = [];\n    if (root !== null) {\n        result.push(root.val);\n        result.push(...preorderTraversal(root.left));\n        result.push(...preorderTraversal(root.right));\n    }\n    return result;\n};\n\n/**\n * 迭代的方法\n * 拿到一个节点，检查是否为null\n * 非null, 保存值，添加到暂存栈，指向它的left\n * null，则从栈里pop出来一个node，并且指向它的right\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n    let result = [];\n\n    //暂存\n    let temp = [];\n\n    //检查的node\n    let node = root;\n\n    while (node !== null || temp.length > 0) {\n\n        if (node !== null) {\n            result.push(node.val);\n            temp.push(node);\n            node = node.left;\n        } else {\n            node = temp.pop().right\n        }\n    }\n    return result;\n};\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\n/**\n *         1\n       /        \\\n     2           2\n   /   \\       /   \\\n  3     4     4     3\n */\nlet root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(2);\nroot.left.left = new TreeNode(3);\nroot.right.right = new TreeNode(3);\nroot.left.right = new TreeNode(4);\nroot.right.left = new TreeNode(4);\n\nexport default () => {\n    let res = preorderTraversal(root);\n    console.log(res);\n\n    return JSON.stringify(res);\n}","/* eslint-disable no-redeclare */\n/**\n * 121. 买卖股票的最佳时机\n * 给定一个数组, 它的第 i 个元素是一支给定股票第 i 天的价格。\n\n    如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n\n * 注意你不能在买入股票前卖出股票。\n * 根据原数组，(n + 1)  - n 创建一个变化数组,计算变化数组的最大段，最大值\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n    let max = 0;\n    if (prices.length === 0) return max;\n\n    let accList = prices.map((val, index, array) => {\n        if (index === array.length - 1) {\n            return 0;\n        } else {\n            let temp = array[index + 1] - val;\n            return temp;\n        }\n    });\n\n    max = Math.max(...accList);\n\n    //计算区间 max\n    for (let i = 0; i < accList.length; i++) {\n        let sum = 0;\n        //优化：只有最左边，或者，左侧值<0时\n        if (i === 0 || accList[i - 1] < 0) {\n            for (let j = i; j < accList.length; j++) {\n                sum += accList[j];\n                max = Math.max(max, sum);\n            }\n        }\n    }\n\n    return max;\n};\n\n//保存历史最低价，一次遍历\nvar maxProfit = function (prices) {\n    let max = 0;\n    if (prices.length === 0) return max;\n    let minPrice = prices[0];\n    for (let v of prices) {\n        if (v < minPrice) {\n            minPrice = v;\n        } else {\n            if (v - minPrice > max) {\n                max = v - minPrice;\n            }\n        }\n    }\n\n    return max;\n}\n\nexport default () => {\n    // let list = [2,1,2,0,1];\n    let list = [2, 1, 2, 0, 1, 5, 4, 1, 6];\n    let res = maxProfit(list);\n    console.log(res);\n\n    return JSON.stringify(`max profit: ${res}`);\n}","/**\n * 100. 相同的树\n * 给定两个二叉树，编写一个函数来检验它们是否相同。\n * 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 先序遍历，二叉树迭代\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(p === null && q === null) return true;\n    if(p === null || q === null) return false;\n\n    return p.val === q.val && \n    isSameTree(p.left, q.left) &&\n    isSameTree(p.right, q.right);\n};\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\n\nlet root2 = new TreeNode(1);\nroot2.left = new TreeNode(2);\nroot2.right = new TreeNode(3);\n\nexport default () => {\n    let res = isSameTree(root1, root2);\n    console.log(root1, root2, res);\n\n    return `isSame tree ${res}`\n}\n\n\n","/**\n * 543.二叉树的直径\n * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。\n * \n * 一个树经过root节点的直径，就是它左侧的深度 L 右侧的深度 R  + 1\n * 那么，在经过所有节点的直径中，找到最大值就可以了\n * 后序，深度遍历\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nlet diameterOfBinaryTree = function(root) {\n    //在作用域内保存变量\n    let maxRadius = 0;\n    findDepth(root);\n    return maxRadius;\n\n    function findDepth(root){\n        if(root === null) return 0;\n        //max 左侧，右侧\n        let leftDepth = findDepth(root.left);\n        let rightDepth = findDepth(root.right);\n        \n        maxRadius = Math.max(maxRadius, leftDepth + rightDepth);\n        return Math.max(leftDepth, rightDepth) + 1\n    \n    }\n};\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\nroot1.left.left = new TreeNode(4);\nroot1.left.right = new TreeNode(5);\n// root1.right.left = new TreeNode(6)\n/**\n          1\n         / \\\n        2   3\n       / \\     \n      4   5  \n */\nexport default () => {\n    const res = diameterOfBinaryTree(root1)\n    console.log(res);\n    return `depth ${res}`;\n}\n","/**\n * 1013. 将数组分成和相等的三个部分\n * 给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。\n * 形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。\n * \n * \b\b看例子以及描述，排序是不可变的，那么就用双指针i , j 不停滑动计算判断\n * \n * @param {number[]} A\n * @return {boolean}\n */\nvar canThreePartsEqualSum = function(A) {\n    if(A.length < 3) return false;\n    \n    let a = 0, b = 0, c = 0;\n    for(let i = 1;i < A.length - 1; i++) {\n        a += A[i - 1];\n        b = 0;\n        for(let j = i + 1; j < A.length; j++) {\n            b += A[j - 1];\n            if(a === b) {\n                c = sum(A, j, A.length);\n                if(a === c) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\nfunction sum(array, i, j) {\n    let sum = 0;\n    for(let index = i; index < j; index ++) {\n        sum += array[index];\n    }\n\n    return sum;\n}\n\nexport default () => {\n    let list = [3,3,6,5,-2,2,5,1,-9,4]\n    const res = canThreePartsEqualSum(list)\n    console.log(res);\n    return `${res}`;\n}\n\n","/**\n * 1071. 字符串的最大公因子\n * 对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。\n * 返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。\n */\n\n/**\n * 辅助方法，判断x是否为str的公因子，可以使用正则表达式match\n * \n * 根据str1进行切分，1, 1/2, 1/3,....1/n\n * 根据长度判断能否被整除\n * 然后，判断x是否是两个字符串的公因子，第一个match的就是最大的\n * \n * 暴力法\n * \n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar gcdOfStrings = function(str1, str2) {\n    let len1 = str1.length;\n    let len2 = str2.length;\n    if(len1 === 0 || len2 === 0) return '';\n\n    for(let num = 1; num <= len1; num ++) {\n        if(len1 % num === 0) {\n            let xLen = len1 / num;\n            if(len2 % xLen === 0) {\n                //判断string\n                let x = str1.substr(0, xLen);\n                if(isGcd(x, str1) && isGcd(x, str2)) {\n                    return x;\n                }\n            }\n        }\n    }\n\n    return '';\n};\n/**\n * 最大公约数 辗转相除法\n * 辅助方法，判断x是否为str的公因子，可以使用正则表达式match\n * 看了题解改成了，最大公约数的方法，跟暴力法相比效率成倍提升\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n *  \n */\nvar gcdOfStrings = function (str1, str2) {\n    let len1 = str1.length;\n    let len2 = str2.length;\n    if(len1 === 0 || len2 === 0) return '';\n\n    let gcdNum = 1;\n    if(len1 > len2) {\n        gcdNum = gcd(len1, len2);\n    } else {\n        gcdNum = gcd(len2, len1);\n    }\n\n    let str = str1.substr(0, gcdNum);\n    if(isGcd(str, str1) && isGcd(str, str2)) {\n        return str1.substr(0, gcdNum);\n    } else {\n        return '';\n    }\n}\n\n//公因子\nfunction isGcd(x, str) {\n    let reg = new RegExp(`^(${x})+$`, 'i');\n    return reg.test(str);\n}\n\n//最大公约数\n//num1 > num2\nfunction gcd(num1, num2) {\n    let tmp = num1 % num2;\n    if(tmp === 0) {\n        return num2;\n    } else {\n        return gcd(num2, tmp)\n    }\n}\n\nexport default () => {\n    let str1 = 'aaaa';\n    let str2 = 'aaaaab';\n    const res = gcdOfStrings(str1, str2);\n    console.log(res);\n    return `gcd of string: ${res}`;\n}\n","/**\n * 169. 多数元素\n * 给定一个大小为 n 的数组, 找到其中的多数元素。 多数元素是指在数组中出现次数大于[n/2]的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n维护一个最大值，省去第二次遍历\n */\n\n /**\n  * 暴力\n  * 使用map存n个数字，遍历，匹配的+1 最后计算长度\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function(nums) {\n    let lists = new Map();\n\n    let maxNum = 1;\n    let maxEl = nums[0];\n    for(let e of nums) {\n        if(lists.has(e)) {\n            lists.set(e, lists.get(e) + 1);\n\n            //max\n            if(lists.get(e) > maxNum) {\n                maxEl = e;\n                maxNum = lists.get(e);\n            }\n        } else {\n            lists.set(e, 1);\n        }\n    }\n\n    return maxEl;\n};\n\nexport default () => {\n    let a = [1,2,1,2,1,2,1,2,2]\n    const res = majorityElement(a)\n    console.log(res);\n    return `majorityElement ${a} ${res}`;\n}\n","/**\n * 01.06 字符串压缩\n * 利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。\n * 比如，字符串aabcccccaaa会变为a2b1c5a3。\n * 若“压缩”后的字符串没有变短，则返回原先的字符串。\n * 你可以假设字符串中只包含大小写英文字母（a至z）。\n */\n/**\n * 遍历，temp暂存，一致num++ 否则组建输出字符串，temp指向新的\n * @param {string} S\n * @return {string}\n */\nvar compressString = function(S) {\n    let res = '';\n    let temp = '';\n    let num = 0;\n    for(let i = 0; i < S.length; i ++) {\n        if(temp === S.charAt(i)) {\n            num++;\n        } else {\n            if(num > 0)\n                res +=  temp + num\n            temp = S.charAt(i);\n            num = 1;\n        }\n    }\n\n    res += temp + num;\n    if(S.length > res.length){\n        return res;\n    } else {\n        return S;\n    }\n};\n\nexport default {\n    func: () => {\n        const str = 'aabcaaaaa';\n        const res = compressString(str)\n        console.log(res);\n        return `compress ${str} : ${res}`;\n    },\n    title: '01.06 字符串压缩'\n}","/**\n * 1160. 拼写单词\n * 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n\n    假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n\n    注意：每次拼写时，chars 中的每个字母都只能用一次。\n\n    返回词汇表 words 中你掌握的所有单词的 长度之和。\n */\n/**\n * 把chars转换成map 字母，出现次数\n * 如果words的单词，出现的字母都在map中，并且数量不超过num，那么这个字母是true\n * 返回长度增加word的length\n * @param {string[]} words\n * @param {string} chars\n * @return {number}\n */\nvar countCharacters = function(words, chars) {\n    const known = parseWordToMap(chars);\n    let total = 0;\n\n    for(let word of words) {\n        const map1 = parseWordToMap(word);\n        if(test(map1, known)) {\n            console.log(map1, known);\n            total += word.length;\n        }\n    }\n\n    return total;\n};\n\nfunction parseWordToMap(str) {\n    let map = new Map();\n    for(let s of str) {\n        if(map.has(s)) {\n            map.set(s,map.get(s) + 1);\n        } else {\n            map.set(s, 1);\n        }\n    }\n    return map;\n}\n\n/**\n * map1 included in map2\n * @param {*} map1 \n * @param {*} map2 \n */\nfunction test(map1, map2) {\n    for(let k of map1.keys()){\n        if(!map2.has(k) || map2.get(k) < map1.get(k)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nexport default {\n    func: () => {\n        const words = [\"cat\",\"bt\",\"hat\",\"tree\"];\n        const chars = \"atach\";\n        const res = countCharacters(words, chars);\n        console.log(res);\n        return `拼写单词 ${words} ${chars} : ${res}`;\n    },\n    title: '1160. 拼写单词'\n}","/**\n * 836. 矩形重叠\n * 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。\n\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n\n给出两个矩形，判断它们是否重叠并返回结果。\n\n把一个矩形想象成x，y两个范围，当两个矩形的两个范围都有相交的时候，那么这两个矩形重叠\n\n * @param {number[]} rec1\n * @param {number[]} rec2\n * @return {boolean}\n */\nvar isRectangleOverlap = function(rec1, rec2) {\n    let [ax1, ay1, ax2, ay2] = rec1;\n    let [bx1, by1, bx2, by2] = rec2;\n\n    return isRangeOverlap([ax1, ax2], [bx1, bx2]) && isRangeOverlap([ay1, ay2], [by1, by2]);\n};\n\n/**\n * 两个范围是否相交\n * @param {array} a \n * @param {array} b \n */\nfunction isRangeOverlap (a, b){\n    if(a.length !== 2 || b.length !== 2) return false;\n\n    //a 在左边\n    if(a[0] <= b[0]) {\n        return a[1] > b[0];\n    } else {\n        return a[0] < b[1];\n    }\n}\n\nexport default {\n    func: () => {\n        const rec1 = [0,0,2,2];\n        const rec2 = [1,1,3,3];\n\n        const res = isRectangleOverlap(rec1, rec2);\n        console.log(res);\n        return `矩形重叠 ${rec1} ${rec2} : ${res}`;\n    },\n    title: '836. 矩形重叠'\n}","/**\n * 104. 二叉树的最大深度\n * 给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 后序遍历\n * 当前节点深度 = 子节点最大深度 + 1\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (root === null) return 0;\n\n    const left = maxDepth(root.left);\n    const right = maxDepth(root.right);\n    const dep = Math.max(left, right) + 1;\n    return dep;\n};\n\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\nroot1.right.right = new TreeNode(4);\nroot1.right.right.right = new TreeNode(4);\n\nexport default {\n    func: () => {\n        let res = maxDepth(root1);\n        console.log(root1);\n        console.log(res);\n        return `二叉树的最大深度 ${res}`;\n    },\n    title: `104. 二叉树的最大深度`,\n    leetLink: 'https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/js-hou-xu-bian-li-by-egerton/',\n    file: \"leetcode_js/maxDepth.js\"\n}\n\n\n","import React, { useState } from 'react';\nimport './style.sass';\nimport atoi from '../leetcode_js/myAtoi_leetcode08';\nimport flatten from '../leetcode_js/flatten';\nimport longestPalindrome from '../leetcode_js/longestPalindrome';\nimport reverseLinkedList from '../leetcode_js/reverseLinkedList';\nimport mirrorTree101 from '../leetcode_js/mirrorTree101';\nimport candies2 from '../leetcode_js/candies2';\nimport findContinuousSequence from '../leetcode_js/findContinuousSequence';\nimport preorderTraversal from '../leetcode_js/preorderTraversal';\nimport maxProfit from '../leetcode_js/maxProfit';\nimport isSameTree from '../leetcode_js/isSameTree';\nimport diameterOfBinaryTree from '../leetcode_js/diameterOfBinaryTree';\nimport canThreePartsEqualSum from '../leetcode_js/canThreePartsEqualSum';\nimport gcdOfStrings from '../leetcode_js/gcdOfStrings';\nimport majorityElement from '../leetcode_js/majorityElement';\nimport compressString from '../leetcode_js/compressString';\nimport countCharacters from '../leetcode_js/countChars';\nimport isRectangleOverlap from '../leetcode_js/isRectangleOverlap';\nimport maxDepth from '../leetcode_js/maxDepth';\n\nconst urlPrefix = 'https://github.com/andycao/algorithmLearn/blob/master/src/'\nfunction TaskList() {\n    const [result, setResult] = useState();\n\n    return <><ul>\n        <Link func={() => {\n            setResult(longestPalindrome())\n        }}\n            name='5. 最长回文子串'\n            source='leetcode_js/longestPalindrome.js'\n        ></Link>\n        <Link\n            func={() => {\n                setResult(atoi())\n            }}\n            name='8. 字符串转换整数 (atoi)'\n            source=\"leetcode_js/myAtoi_leetcode08.js\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(flatten())\n            }}\n            source=\"leetcode_js/flatten.js\"\n            name='手写flat'\n        ></Link>\n        <Link\n            func={() => {\n                setResult(reverseLinkedList())\n            }}\n            name='反转链表'\n            source=\"leetcode_js/reverseLinkedList.js\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(mirrorTree101())\n            }}\n            name='镜像二叉树'\n            source=\"leetcode_js/mirrorTree101.js\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(candies2())\n            }}\n            name='1103.分糖果2'\n            source=\"leetcode_js/candies2.js\"\n            leetLink=\"https://leetcode-cn.com/problems/distribute-candies-to-people/solution/js-shu-zu-by-egerton/\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(findContinuousSequence())\n            }}\n            name='57 - II 连续正整数序列'\n            source=\"leetcode_js/findContinuousSequence.js\"\n            leetLink=\"https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/javascript-shuang-zhi-zhen-hua-dong-chuang-kou-by-/\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(preorderTraversal())\n            }}\n            name='144.二叉树先序遍历'\n            source=\"leetcode_js/preorderTraversal.js\"\n            leetLink=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/di-gui-zan-cun-zhan-by-egerton/\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(maxProfit())\n            }}\n            name='121. 买卖股票的最佳时机'\n            source=\"leetcode_js/maxProfit.js\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(maxProfit())\n            }}\n            name='121. 买卖股票的最佳时机'\n            source=\"leetcode_js/maxProfit.js\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(isSameTree())\n            }}\n            name='100. 相同的树'\n            source=\"leetcode_js/isSameTree.js\"\n            leetLink='https://leetcode-cn.com/problems/same-tree/solution/javascript-xian-xu-bian-li-by-egerton/'\n        ></Link>\n        <Link\n            func={() => {\n                setResult(diameterOfBinaryTree())\n            }}\n            name='543.二叉树的直径'\n            source=\"leetcode_js/diameterOfBinaryTree.js\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(canThreePartsEqualSum())\n            }}\n            name='1013.数组三等分'\n            source=\"leetcode_js/diameterOfBinaryTree.js\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(gcdOfStrings())\n            }}\n            name='1071. 字符串的最大公因子'\n            source=\"leetcode_js/gcdOfStrings.js\"\n            leetLink=\"https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/qie-fen-zheng-ze-biao-da-shi-by-egerton/\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(majorityElement())\n            }}\n            name='169. 多数元素'\n            source=\"leetcode_js/majorityElement.js\"\n            leetLink=\"https://leetcode-cn.com/problems/majority-element/solution/js-bao-li-fa-you-hua-by-egerton/\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(compressString.func)\n            }}\n            name={compressString.title}\n            source=\"leetcode_js/compressString.js\"\n            leetLink=\"https://leetcode-cn.com/problems/compress-string-lcci/solution/js-bian-li-by-egerton/\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(countCharacters.func)\n            }}\n            name={countCharacters.title}\n            source=\"leetcode_js/countChars.js\"\n            leetLink=\"https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/solution/js-bao-li-fa-by-egerton-2/\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(isRectangleOverlap.func)\n            }}\n            name={isRectangleOverlap.title}\n            source=\"leetcode_js/isRectangleOverlap.js\"\n        ></Link>\n        <Link\n            func={() => {\n                setResult(maxDepth.func)\n            }}\n            name={maxDepth.title}\n            source={maxDepth.file}\n            leetLink={maxDepth.leetLink}\n        ></Link>\n    </ul>\n        <div className=\"result\">\n            {result}\n        </div>\n    </>;\n}\n\nfunction Link(props) {\n    return <li>\n        <span>{props.name}</span>\n        <span className=\"link\" onClick={() => {\n            window.open(urlPrefix + props.source)\n        }}>源码</span>\n        <span className=\"link\" onClick={props.func}>运行</span>\n        {props.leetLink?<span className=\"link\" onClick={() => {\n            window.open(props.leetLink)\n        }}>leetcode题解</span> : null}\n    </li>;\n}\n\nexport default TaskList;","import React from 'react';\nimport Header from './pages/header';\nimport TaskList from './pages/list';\n\nclass App extends React.Component {\n    render(){\n        return (<div className='container'>\n            <Header />\n            <TaskList />\n        </div>);\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}