{"version":3,"sources":["pages/header.js","leetcode_js/isValidBST.js","leetcode_js/longestPalindrome2.js","leetcode_js/maxDepth.js","leetcode_js/isRectangleOverlap.js","leetcode_js/countChars.js","leetcode_js/compressString.js","leetcode_js/majorityElement.js","leetcode_js/gcdOfStrings.js","leetcode_js/canThreePartsEqualSum.js","leetcode_js/isSameTree.js","leetcode_js/candies2.js","leetcode_js/findContinuousSequence.js","leetcode_js/preorderTraversal.js","leetcode_js/myAtoi.js","leetcode_js/flatten.js","leetcode_js/longestPalindrome.js","leetcode_js/reverseLinkedList.js","leetcode_js/mirrorTree.js","leetcode_js/maxProfit.js","leetcode_js/diameterOfBinaryTree.js","leetcode_js/getLeastNumbers.js","leetcode_js/canMeasureWater.js","leetcode_js/middleNode.js","leetcode_js/invertTree.js","leetcode_js/numTrees.js","leetcode_js/index.js","leetcode_js/surfaceArea.js","leetcode_js/numRookCaptures.js","pages/list.js","App.js","serviceWorker.js","index.js"],"names":["Header","href","target","isValidBST","root","left","right","val","maxVal","Number","MAX_SAFE_INTEGER","minVal","prev","MIN_SAFE_INTEGER","res","inorder","node","TreeNode","this","root1","func","console","log","title","file","leetLink","s","len","chars","Set","e","has","delete","add","size","longestPalindrome2","maxDepth","Math","max","isRangeOverlap","a","b","length","rec1","rec2","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","isRectangleOverlap","parseWordToMap","str","map","Map","set","get","test","map1","map2","keys","k","words","known","total","word","countCharacters","S","temp","num","i","charAt","compressString","nums","lists","maxNum","maxEl","majorityElement","isGcd","x","RegExp","gcd","num1","num2","tmp","str1","str2","len1","len2","gcdNum","substr","gcdOfStrings","sum","array","j","index","A","canThreePartsEqualSum","root2","isSameTree","p","q","candies","num_people","Array","fill","distributeCandies","JSON","stringify","result","l","r","mid","ceil","push","findContinuousSequence","preorderTraversal","pop","trim","exec","parseInt","myAtoi","flatten","reduce","acc","concat","isArray","findLongestAround","out","floor","longestPalindrome","reverseList","head","newHead","next","reverse","pre","cur","ListNode","h1","old","newH","list","shift","isSymmetric","prices","minPrice","v","maxProfit","maxRadius","findDepth","leftDepth","rightDepth","diameterOfBinaryTree","arr","slice","getLeastNumbers","canMeasureWater","y","z","big","small","min","t","calc","includes","canMeasureWater2","res2","fast","slow","middleNode","results","atoi","reverseLinkedList","mirrorTree","candies2","countChars","invertTree","grid","blocks","faces","h","surfaceArea","board","R","forR","c","top","bottom","numRookCaptures","numTrees","n","urlPrefix","LinkNew","props","answer","setResult","className","onClick","window","open","TaskList","useState","leetcodeList","entry","key","App","document","React","Component","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f037ebca.chunk.js","sourcesContent":["import React from 'react';\nfunction Header() {\n    return (\n        <div>\n            <h2>算法学习记录</h2>\n            <p>运行查看执行结果，console</p>\n            <p><a href=\"https://leetcode-cn.com/u/egerton/\" target=\"blank\">我的Leetcode</a></p>\n            <hr></hr>\n        </div>\n    );\n}\n\nexport default Header;","/**\n * 98. 验证二叉搜索树\n * 给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n * \n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 如果一个树是bst，那么他的每个节点n的 n.left也是一个bst, n.right也是一个bst\n * 并且n.val > n.left.max, n.val < n.right.min\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function (root) {\n    if (root === null) return true;\n\n    return isValidBST(root.left) && isValidBST(root.right) && root.val > maxVal(root.left) &&\n        root.val < minVal(root.right);\n};\n\n/**\n * 利用中序遍历的读取顺序，只要当前val比上一个val大就可以了\n * 默认值为最小值\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function (root) {\n    let prev = Number.MIN_SAFE_INTEGER;\n    let res = true;\n    inorder(root);\n    return res;\n    function inorder(node) {\n        if (node !== null && res) {\n            inorder(node.left);\n            res = res && node.val > prev;\n            prev = node.val;\n            inorder(node.right);\n        }\n    }\n};\n\n/**\n * 找出一棵bst的max\n * 最右边的值\n * @param {TreeNode} root \n */\nfunction maxVal(root) {\n    if (root === null) return Number.MIN_SAFE_INTEGER;\n    if (root.right) return maxVal(root.right);\n    else return root.val;\n}\n\n/**\n * 找出一棵bst的min\n * 最左边的值\n * @param {TreeNode} root \n */\nfunction minVal(root) {\n    if (root === null) return Number.MAX_SAFE_INTEGER;\n    if (root.left) return maxVal(root.left);\n    else return root.val;\n}\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(3);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(5);\nroot1.right.right = new TreeNode(6);\nroot1.right.left = new TreeNode(4);\nroot1.right.right.right = new TreeNode(7);\n\nexport default {\n    func: () => {\n        let res = isValidBST(root1);\n        console.log(root1);\n        console.log(res);\n        return `验证二叉搜索树 ${res}`;\n    },\n    title: `98. 验证二叉搜索树`,\n    file: \"leetcode_js/isValidBST.js\",\n    leetLink: 'https://leetcode-cn.com/problems/validate-binary-search-tree/solution/shen-du-you-xian-zhong-xu-bian-li-by-egerton/'\n}\n\n\n","/**\n * 409. 最长回文串\n * 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n * 在构造过程中，请注意区分大小写。比如 \"Aa\" 不能当做一个回文字符串。\n * \n*/\n/**\n * 遍历一遍s，使用set保存字母e，\n * 有重复的，长度+2，并去除\n * 不存在，则添加\n * 最后，看set，非空则长度+1\n * @param {string} s\n * @return {number}\n */\nvar longestPalindrome2 = function(s) {\n    let len = 0;\n    let chars = new Set();\n    for(let e of s) {\n        if(chars.has(e)) {\n            len += 2;\n            chars.delete(e);\n        } else {\n            chars.add(e);\n        }\n    }\n\n    if(chars.size !== 0) {\n        len += 1;\n    }\n\n    return len;\n};\nexport default {\n    func: () => {\n        const s = 'aaaaaaaaaaab';\n        let res = longestPalindrome2(s);\n        console.log(res);\n        return `最长回文串 ${s} ${res}`;\n    },\n    title: `409. 最长回文串`,\n    file: \"leetcode_js/longestPalindrome2.js\",\n    leetLink: 'https://leetcode-cn.com/problems/longest-palindrome/solution/bian-li-zi-fu-chuan-by-egerton/'\n}\n\n\n","/**\n * 104. 二叉树的最大深度\n * 给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 后序遍历\n * 当前节点深度 = 子节点最大深度 + 1\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (root === null) return 0;\n\n    const left = maxDepth(root.left);\n    const right = maxDepth(root.right);\n    const dep = Math.max(left, right) + 1;\n    return dep;\n};\n\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\nroot1.right.right = new TreeNode(4);\nroot1.right.right.right = new TreeNode(4);\n\nexport default {\n    func: () => {\n        let res = maxDepth(root1);\n        console.log(root1);\n        console.log(res);\n        return `二叉树的最大深度 ${res}`;\n    },\n    title: `104. 二叉树的最大深度`,\n    leetLink: 'https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/js-hou-xu-bian-li-by-egerton/',\n    file: \"leetcode_js/maxDepth.js\"\n}\n\n\n","/**\n * 836. 矩形重叠\n * 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。\n\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n\n给出两个矩形，判断它们是否重叠并返回结果。\n\n把一个矩形想象成x，y两个范围，当两个矩形的两个范围都有相交的时候，那么这两个矩形重叠\n\n * @param {number[]} rec1\n * @param {number[]} rec2\n * @return {boolean}\n */\nvar isRectangleOverlap = function(rec1, rec2) {\n    let [ax1, ay1, ax2, ay2] = rec1;\n    let [bx1, by1, bx2, by2] = rec2;\n\n    return isRangeOverlap([ax1, ax2], [bx1, bx2]) && isRangeOverlap([ay1, ay2], [by1, by2]);\n};\n\n/**\n * 两个范围是否相交\n * @param {array} a \n * @param {array} b \n */\nfunction isRangeOverlap (a, b){\n    if(a.length !== 2 || b.length !== 2) return false;\n\n    //a 在左边\n    if(a[0] <= b[0]) {\n        return a[1] > b[0];\n    } else {\n        return a[0] < b[1];\n    }\n}\n\nexport default {\n    func: () => {\n        const rec1 = [0,0,2,2];\n        const rec2 = [1,1,3,3];\n\n        const res = isRectangleOverlap(rec1, rec2);\n        console.log(res);\n        return `矩形重叠 ${rec1} ${rec2} : ${res}`;\n    },\n    title: '836. 矩形重叠',\n    file: \"leetcode_js/isRectangleOverlap.js\",\n}","/**\n * 1160. 拼写单词\n * 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n\n    假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n\n    注意：每次拼写时，chars 中的每个字母都只能用一次。\n\n    返回词汇表 words 中你掌握的所有单词的 长度之和。\n */\n/**\n * 把chars转换成map 字母，出现次数\n * 如果words的单词，出现的字母都在map中，并且数量不超过num，那么这个字母是true\n * 返回长度增加word的length\n * @param {string[]} words\n * @param {string} chars\n * @return {number}\n */\nvar countCharacters = function(words, chars) {\n    const known = parseWordToMap(chars);\n    let total = 0;\n\n    for(let word of words) {\n        const map1 = parseWordToMap(word);\n        if(test(map1, known)) {\n            console.log(map1, known);\n            total += word.length;\n        }\n    }\n\n    return total;\n};\n\nfunction parseWordToMap(str) {\n    let map = new Map();\n    for(let s of str) {\n        if(map.has(s)) {\n            map.set(s,map.get(s) + 1);\n        } else {\n            map.set(s, 1);\n        }\n    }\n    return map;\n}\n\n/**\n * map1 included in map2\n * @param {*} map1 \n * @param {*} map2 \n */\nfunction test(map1, map2) {\n    for(let k of map1.keys()){\n        if(!map2.has(k) || map2.get(k) < map1.get(k)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nexport default {\n    func: () => {\n        const words = [\"cat\",\"bt\",\"hat\",\"tree\"];\n        const chars = \"atach\";\n        const res = countCharacters(words, chars);\n        console.log(res);\n        return `拼写单词 ${words} ${chars} : ${res}`;\n    },\n    title: '1160. 拼写单词',\n    file: \"leetcode_js/countChars.js\",\n\n}","/**\n * 01.06 字符串压缩\n * 利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。\n * 比如，字符串aabcccccaaa会变为a2b1c5a3。\n * 若“压缩”后的字符串没有变短，则返回原先的字符串。\n * 你可以假设字符串中只包含大小写英文字母（a至z）。\n */\n/**\n * 遍历，temp暂存，一致num++ 否则组建输出字符串，temp指向新的\n * @param {string} S\n * @return {string}\n */\nvar compressString = function(S) {\n    let res = '';\n    let temp = '';\n    let num = 0;\n    for(let i = 0; i < S.length; i ++) {\n        if(temp === S.charAt(i)) {\n            num++;\n        } else {\n            if(num > 0)\n                res +=  temp + num\n            temp = S.charAt(i);\n            num = 1;\n        }\n    }\n\n    res += temp + num;\n    if(S.length > res.length){\n        return res;\n    } else {\n        return S;\n    }\n};\n\nexport default {\n    func: () => {\n        const str = 'aabcaaaaa';\n        const res = compressString(str)\n        console.log(res);\n        return `compress ${str} : ${res}`;\n    },\n    title: '01.06 字符串压缩',\n    file: \"leetcode_js/compressString.js\",\n}","/**\n * 169. 多数元素\n * 给定一个大小为 n 的数组, 找到其中的多数元素。 多数元素是指在数组中出现次数大于[n/2]的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n维护一个最大值，省去第二次遍历\n */\n\n/**\n * 暴力\n * 使用map存n个数字，遍历，匹配的+1 最后计算长度\n* @param {number[]} nums\n* @return {number}\n*/\nvar majorityElement = function (nums) {\n    let lists = new Map();\n\n    let maxNum = 1;\n    let maxEl = nums[0];\n    for (let e of nums) {\n        if (lists.has(e)) {\n            lists.set(e, lists.get(e) + 1);\n\n            //max\n            if (lists.get(e) > maxNum) {\n                maxEl = e;\n                maxNum = lists.get(e);\n            }\n        } else {\n            lists.set(e, 1);\n        }\n    }\n\n    return maxEl;\n};\n\nexport default {\n    func: () => {\n        let a = [1, 2, 1, 2, 1, 2, 1, 2, 2]\n        const res = majorityElement(a)\n        console.log(res);\n        return `majorityElement ${a} ${res}`;\n    },\n    title: '169. 多数元素',\n    file: \"leetcode_js/majorityElement.js\",\n    leetLink: \"https://leetcode-cn.com/problems/majority-element/solution/js-bao-li-fa-you-hua-by-egerton/\"\n}","/**\n * 1071. 字符串的最大公因子\n * 对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。\n * 返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。\n */\n\n/**\n * 辅助方法，判断x是否为str的公因子，可以使用正则表达式match\n * \n * \n * 根据str1进行切分，1, 1/2, 1/3,....1/n\n * 根据长度判断能否被整除\n * 然后，判断x是否是两个字符串的公因子，第一个match的就是最大的\n * \n * 暴力法\n * \n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar gcdOfStrings = function (str1, str2) {\n    let len1 = str1.length;\n    let len2 = str2.length;\n    if (len1 === 0 || len2 === 0) return '';\n\n    for (let num = 1; num <= len1; num++) {\n        if (len1 % num === 0) {\n            let xLen = len1 / num;\n            if (len2 % xLen === 0) {\n                //判断string\n                let x = str1.substr(0, xLen);\n                if (isGcd(x, str1) && isGcd(x, str2)) {\n                    return x;\n                }\n            }\n        }\n    }\n\n    return '';\n};\n/**\n * 最大公约数 辗转相除法\n * 辅助方法，判断x是否为str的公因子，可以使用正则表达式match\n * 看了题解改成了，最大公约数的方法，跟暴力法相比效率成倍提升\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n *  \n */\nvar gcdOfStrings = function (str1, str2) {\n    let len1 = str1.length;\n    let len2 = str2.length;\n    if (len1 === 0 || len2 === 0) return '';\n\n    let gcdNum = 1;\n    if (len1 > len2) {\n        gcdNum = gcd(len1, len2);\n    } else {\n        gcdNum = gcd(len2, len1);\n    }\n\n    let str = str1.substr(0, gcdNum);\n    if (isGcd(str, str1) && isGcd(str, str2)) {\n        return str1.substr(0, gcdNum);\n    } else {\n        return '';\n    }\n}\n\n//公因子\nfunction isGcd(x, str) {\n    let reg = new RegExp(`^(${x})+$`, 'i');\n    return reg.test(str);\n}\n\n//最大公约数\n//num1 > num2\nfunction gcd(num1, num2) {\n    let tmp = num1 % num2;\n    if (tmp === 0) {\n        return num2;\n    } else {\n        return gcd(num2, tmp)\n    }\n}\n\nexport default {\n    func: () => {\n        let str1 = 'aaaaaaaa';\n        let str2 = 'aaaa';\n        const res = gcdOfStrings(str1, str2);\n        console.log(res);\n        return `gcd of string: ${res}`;\n    },\n    title: '1071. 字符串的最大公因子',\n    file: \"leetcode_js/gcdOfStrings.js\",\n    leetLink: \"https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/qie-fen-zheng-ze-biao-da-shi-by-egerton/\"\n}","/**\n * 1013. 将数组分成和相等的三个部分\n * 给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。\n * 形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。\n * \n * \b\b看例子以及描述，排序是不可变的，那么就用双指针i , j 不停滑动计算判断\n * \n * @param {number[]} A\n * @return {boolean}\n */\nvar canThreePartsEqualSum = function (A) {\n    if (A.length < 3) return false;\n\n    let a = 0, b = 0, c = 0;\n    for (let i = 1; i < A.length - 1; i++) {\n        a += A[i - 1];\n        b = 0;\n        for (let j = i + 1; j < A.length; j++) {\n            b += A[j - 1];\n            if (a === b) {\n                c = sum(A, j, A.length);\n                if (a === c) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\nfunction sum(array, i, j) {\n    let sum = 0;\n    for (let index = i; index < j; index++) {\n        sum += array[index];\n    }\n\n    return sum;\n}\n\nexport default {\n    func: () => {\n        let list = [3, 3, 6, 5, -2, 2, 5, 1, -9, 4]\n        const res = canThreePartsEqualSum(list)\n        console.log(res);\n        return `${res}`;\n    },\n    title: '1013. 数组三等分',\n    file: \"leetcode_js/diameterOfBinaryTree.js\",\n}","/**\n * 100. 相同的树\n * 给定两个二叉树，编写一个函数来检验它们是否相同。\n * 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 先序遍历，二叉树迭代\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n    if (p === null && q === null) return true;\n    if (p === null || q === null) return false;\n\n    return p.val === q.val &&\n        isSameTree(p.left, q.left) &&\n        isSameTree(p.right, q.right);\n};\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\n\nlet root2 = new TreeNode(1);\nroot2.left = new TreeNode(2);\nroot2.right = new TreeNode(3);\n\nexport default {\n    func: () => {\n        let res = isSameTree(root1, root2);\n        console.log(root1, root2, res);\n\n        return `isSame tree ${res}`\n    },\n    title: '100. 相同的树',\n    file: \"leetcode_js/isSameTree.js\",\n    leetLink: 'https://leetcode-cn.com/problems/same-tree/solution/javascript-xian-xu-bian-li-by-egerton/'\n\n}","/**\n * 1103 分糖果2\n * 排排坐，分糖果。\n\n我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。\n\n给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。\n\n然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。\n\n重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。\n\n返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。\n\n \n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/distribute-candies-to-people\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n * 定义一个数组，数组长度n, 顺序给数组的值 +糖果数\n * @param {number} candies\n * @param {number} num_people\n * @return {number[]}\n */\nvar distributeCandies = function(candies, num_people) {\n    let array = new Array(num_people).fill(0);\n\n    let i = 0;\n    let num = 1;\n    while(candies > 0) {\n        if(num > candies) {\n            num = candies;\n        }\n        array[i] += num;\n        candies -= num;\n\n        num += 1;\n        i = ++i % num_people;\n    }\n\n    console.log(array);\n\n    return array;\n    \n};\n\nexport default {\n    func: () => {\n        const res = distributeCandies(16, 3)\n    console.log(res);\n    return JSON.stringify(res);\n    },\n    title: '1103.分糖果2',\n    file: \"leetcode_js/candies2.js\",\n    leetLink: \"https://leetcode-cn.com/problems/distribute-candies-to-people/solution/js-shu-zu-by-egerton/\"\n}","/**\n * 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n示例 1：\n\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n示例 2：\n\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n \n\n限制：\n\n1 <= target <= 10^5\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n * 暴力的方法，1 ~ target / 2，每个数开始，加起来看看是否相等于target\n 小于则继续加，大于则不成立，等于则数组有效\n * @param {number} target\n * @return {number[][]}\n */\nvar findContinuousSequence = function (target) {\n    let result = [];\n    //1\n    if (target === 1) {\n        return result;\n    }\n\n    //从1 开始 到 Math.ceil(target / 2)\n    for (let i = 1; i < Math.ceil(target / 2); i++) {\n        let sum = 0;\n        let acc = i;\n        while (sum <= target) {\n            if (sum < target) {\n                sum += acc++;\n            } else if (sum === target) {\n                //equal array from i ~ acc\n                let array = [];\n                for (let index = i; index < acc; index++) {\n                    array.push(index);\n                }\n\n                result.push(array);\n\n                break;\n            }\n        }\n    }\n\n    return result;\n};\n/*\n* 滑动窗口 \n定义左侧，右侧，l,r  1,2\n计算l ~ r 的和，< target l不变，r可以向右扩展\n= target 则l r组合正确，而且l开头的组合就这一个保存并且l + 1，r + 1。 \n    l+1 r 的组合肯定小于target。l最远能到target / 2中间\n>target 则l 开头没有正确组合， l + 1, r不变\n当l > target / 2 或l >= r时结束循环，返回结果\n\n* @param {number} target\n* @return {number[][]}\n*/\nvar findContinuousSequence = function (target) {\n    let result = [];\n    if (target === 1) return result;\n    let l = 1;\n    let r = 2;\n\n    let sum = 0;\n    let mid = Math.ceil(target / 2);\n    while (l < mid && l < r) {\n        sum = (l + r) * (r - l + 1) / 2;\n        if (sum < target) {\n            r++;\n        } else if (sum === target) {\n            let array = [];\n            for (let index = l; index <= r; index++) {\n                array.push(index);\n            }\n            result.push(array);\n\n            l++;\n            r++;\n        } else {\n            l++;\n        }\n    }\n\n    return result;\n}\n\nexport default {\n    func: () => {\n        const res = findContinuousSequence(15)\n        console.log(res);\n        return JSON.stringify(res);\n    },\n    title: '57 - II 连续正整数序列',\n    file: \"leetcode_js/findContinuousSequence.js\",\n    leetLink: \"https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/javascript-shuang-zhi-zhen-hua-dong-chuang-kou-by-/\"\n}","/**\n * 144.给定一个二叉树，返回它的 先序 遍历。\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 递归的方法，先访问本节点value，再访问左节点，再右节点\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n    let result = [];\n    if (root !== null) {\n        result.push(root.val);\n        result.push(...preorderTraversal(root.left));\n        result.push(...preorderTraversal(root.right));\n    }\n    return result;\n};\n\n/**\n * 迭代的方法\n * 拿到一个节点，检查是否为null\n * 非null, 保存值，添加到暂存栈，指向它的left\n * null，则从栈里pop出来一个node，并且指向它的right\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n    let result = [];\n\n    //暂存\n    let temp = [];\n\n    //检查的node\n    let node = root;\n\n    while (node !== null || temp.length > 0) {\n\n        if (node !== null) {\n            result.push(node.val);\n            temp.push(node);\n            node = node.left;\n        } else {\n            node = temp.pop().right\n        }\n    }\n    return result;\n};\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\n/**\n *         1\n       /        \\\n     2           2\n   /   \\       /   \\\n  3     4     4     3\n */\nlet root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(2);\nroot.left.left = new TreeNode(3);\nroot.right.right = new TreeNode(3);\nroot.left.right = new TreeNode(4);\nroot.right.left = new TreeNode(4);\n\nexport default {\n    func: () => {\n        let res = preorderTraversal(root);\n        console.log(res);\n\n        return `先序遍历 ${JSON.stringify(res)}`;\n    },\n    title: '144. 二叉树先序遍历',\n    file: \"leetcode_js/preorderTraversal.js\",\n    leetLink: \"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/di-gui-zan-cun-zhan-by-egerton/\"\n}","/**\n * 8. 字符串转换整数 (atoi)\n * @param {string} str\n * @return {number}\n */\nlet max = 2147483648 - 1;\nlet min = -2147483648;\nvar myAtoi = function (str) {\n    let s = str.trim();\n\n    let reg = /^[+-]?\\d+/;\n    let res = reg.exec(s);\n    if (res) {\n        let num = parseInt(res[0]);\n        if (num > max) return max;\n        else if (num < min) return min;\n        else return num;\n    } else {\n        return 0;\n    }\n};\n\nexport default {\n    func: () => {\n        const res = myAtoi('-91283472332-=')\n        console.log(res);\n\n        return `${res}`;\n    },\n    title: '8. 字符串转换整数',\n    file: \"leetcode_js/myAtoi.js\",\n}","// const flatten = function (array) {\n//     let result = [];\n//     for(let e of array) {\n//         if(Array.isArray(e)) {\n//             result.push(...flatten(e))\n//         } else {\n//             result.push(e)\n//         }\n//     }\n//     return result;\n// }\n\nconst flatten = function (array) {\n    return array.reduce(\n        (acc, val) => acc.concat(Array.isArray(val) ? flatten(val) : val),\n        [])\n}\n\n\nexport default {\n    func: () => {\n        const res = flatten([1, 2, 3, [4, 5, 6, [7, 8]]])\n        console.log(res);\n\n        return `${res}`;\n    },\n    title: '手写flat',\n    file: \"leetcode_js/flatten.js\",\n}","/* eslint-disable no-unused-vars */\n/**\n * 5. 最长回文子串\n * 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n\n    let res = '';\n\n    for (let i = 0; i < s.length; i++) {\n        let len1 = findLongestAround(s, i, i); //奇数\n        let len2 = findLongestAround(s, i, i + 1) //偶数\n        let len = Math.max(len1, len2);\n        if(len > res.length) {\n            res = s.substr(i - Math.floor((len - 1) / 2), len);\n        }\n    }\n\n    return res;\n};\n\nfunction testPalindrome(str) {\n    let reverse = [...str].reverse().join('');\n    return reverse === str;\n}\n\nfunction testPal(str, i, j) {\n    while(i < j) {\n        if(str.charAt(i) !== str.charAt(j)){\n            return false\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n\nfunction findLongestAround(str, left, right) {\n\n    while (left >= 0 && right < str.length && str.charAt(left) === str.charAt(right)) {\n        left--;\n        right++;\n    }\n    return right - left - 1\n}\n\nconst longestPalindromeViolence = function (str) {\n    const len = str.length;\n    if(len < 2) {\n        return str;\n    }\n\n    let res = str.substr(0, 1);\n    for (let i = 0; i < len; i++) {\n        for(let j = i; j < len; j++) {\n            if(j - i + 1 > res.length && testPal(str, i, j)) {\n                res = str.substr(i, j - i + 1);\n            }\n        }\n    }\n\n    return res;\n}\n\nexport default {\n    func: () => {\n        let input = 'abcabcabcabccedabbac'\n        let out = longestPalindrome(input)\n        console.log(out);\n\n        return `最长回文子串 ${out}`;\n    },\n    title: '5. 最长回文子串',\n    file: \"leetcode_js/longestPalindrome.js\",\n}","/**\n * 反转链表\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * 迭代的方法\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    let newHead = null;\n    let temp = head;\n    while (temp) {\n        temp = head.next;\n        head.next = newHead;\n        newHead = head;\n        head = temp;\n    }\n\n    return newHead;\n};\n\n\n/**\n * 递归的方法\n * 反向递归\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    if (head == null || head.next == null)\n        return head;\n\n    let res = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n\n    return res;\n};\n\nvar reverseList = (head) => {\n    // debugger\n    let reverse = (pre, cur) => {\n        if (!cur) return pre;\n        // 保存 next 节点\n        let next = cur.next;\n        cur.next = pre;\n        return reverse(cur, next);\n    }\n    return reverse(null, head);\n}\n\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nlet h1 = new ListNode(1);\nh1.next = new ListNode(2);\nh1.next.next = new ListNode(3);\nh1.next.next.next = new ListNode(4);\n\n\nexport default {\n    func: () => {\n        let old = JSON.stringify(h1);\n    let newH = reverseList(h1);\n    console.log('old', old);\n    console.log('new', newH);\n\n    return JSON.stringify(newH)\n\n    },\n    title: '反转链表',\n    file: \"leetcode_js/reverseLinkedList.js\",\n}","/* eslint-disable no-redeclare */\n/**\n * 101 给定一个二叉树，检查它是否是镜像对称的。\n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n           1\n       /        \\\n     2           2\n   /   \\       /   \\\n  3     4     4     3\n / \\   / \\   / \\   / \\\n5   6 7   8 8   7 6   5\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/symmetric-tree\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 递归的方法，如果两个树是镜像树的话，那么他们的值相等，并且一个的左边，与另一个的右边互为镜像树\n * 一个的右边与另一个的左边互为镜像树\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n    return isMirror(root, root);\n};\n\nfunction isMirror(nodeLeft, nodeRight) {\n    if (nodeLeft === null && nodeRight === null) {\n        return true;\n    } else if (nodeLeft === null || nodeRight === null) {\n        return false;\n    } else if (nodeLeft.val === nodeRight.val &&\n        isMirror(nodeLeft.left, nodeRight.right) &&\n        isMirror(nodeLeft.right, nodeRight.left)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * 递归，除了root向队列里推左右两边，shift出来2个元素，比较相同。如果相等，继续推两个元素的左边，右边一对，右边，左边一对\n * 不相等时退出，两个元素同为null时退出\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n    if(root === null) return true;\n    let list = [root.left, root.right];\n    \n    while(list.length > 0) {\n        let a = list.shift();\n        let b = list.shift();\n\n        if(a === null && b == null) {\n            continue;\n        } else if(a === null || b === null) {\n            return false;\n        } else if(a.val === b.val) {\n            list.push(a.left, b.right);\n            list.push(a.right, b.left);\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(2);\nroot.left.left = new TreeNode(3);\nroot.right.right = new TreeNode(3);\nroot.left.right = new TreeNode(4);\nroot.right.left = new TreeNode(4);\n\nexport default {\n    func: () => {\n        let res = isSymmetric(root);\n        console.log(res);\n\n        return `isSymmetric ${res}`\n    },\n    title: '101. 镜像二叉树',\n    file: \"leetcode_js/mirrorTree.js\",\n}","/* eslint-disable no-redeclare */\n/**\n * 121. 买卖股票的最佳时机\n * 给定一个数组, 它的第 i 个元素是一支给定股票第 i 天的价格。\n\n    如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n\n * 注意你不能在买入股票前卖出股票。\n * 根据原数组，(n + 1)  - n 创建一个变化数组,计算变化数组的最大段，最大值\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n    let max = 0;\n    if (prices.length === 0) return max;\n\n    let accList = prices.map((val, index, array) => {\n        if (index === array.length - 1) {\n            return 0;\n        } else {\n            let temp = array[index + 1] - val;\n            return temp;\n        }\n    });\n\n    max = Math.max(...accList);\n\n    //计算区间 max\n    for (let i = 0; i < accList.length; i++) {\n        let sum = 0;\n        //优化：只有最左边，或者，左侧值<0时\n        if (i === 0 || accList[i - 1] < 0) {\n            for (let j = i; j < accList.length; j++) {\n                sum += accList[j];\n                max = Math.max(max, sum);\n            }\n        }\n    }\n\n    return max;\n};\n\n//保存历史最低价，一次遍历\nvar maxProfit = function (prices) {\n    let max = 0;\n    if (prices.length === 0) return max;\n    let minPrice = prices[0];\n    for (let v of prices) {\n        if (v < minPrice) {\n            minPrice = v;\n        } else {\n            if (v - minPrice > max) {\n                max = v - minPrice;\n            }\n        }\n    }\n\n    return max;\n}\n\nexport default {\n    func: () => {\n        // let list = [2,1,2,0,1];\n    let list = [2, 1, 2, 0, 1, 5, 4, 1, 6];\n    let res = maxProfit(list);\n    console.log(res);\n\n    return JSON.stringify(`max profit: ${res}`);\n    },\n    title: '121. 买卖股票的最佳时机',\n    file: \"leetcode_js/maxProfit.js\",\n}","/**\n * 543.二叉树的直径\n * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。\n * \n * 一个树经过root节点的直径，就是它左侧的深度 L 右侧的深度 R  + 1\n * 那么，在经过所有节点的直径中，找到最大值就可以了\n * 后序，深度遍历\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nlet diameterOfBinaryTree = function (root) {\n    //在作用域内保存变量\n    let maxRadius = 0;\n    findDepth(root);\n    return maxRadius;\n\n    function findDepth(root) {\n        if (root === null) return 0;\n        //max 左侧，右侧\n        let leftDepth = findDepth(root.left);\n        let rightDepth = findDepth(root.right);\n\n        maxRadius = Math.max(maxRadius, leftDepth + rightDepth);\n        return Math.max(leftDepth, rightDepth) + 1\n\n    }\n};\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\nroot1.left.left = new TreeNode(4);\nroot1.left.right = new TreeNode(5);\n// root1.right.left = new TreeNode(6)\n/**\n          1\n         / \\\n        2   3\n       / \\     \n      4   5  \n */\n\nexport default {\n    func: () => {\n        const res = diameterOfBinaryTree(root1)\n        console.log(res);\n        return `直径 ${res}`;\n    },\n    title: '543.二叉树的直径',\n    file: \"leetcode_js/diameterOfBinaryTree.js\",\n}","/**\n * 40. 最小的k个数\n * 输入整数数组 arr ，找出其中最小的 k 个数。\n * 例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n */\n/**\n * 暴力一点，对字符串排序，前k个\n * @param {number[]} arr\n * @param {number} k\n * @return {number[]}\n */\nvar getLeastNumbers = function (arr, k) {\n    arr.sort((a, b) => a - b);\n    return arr.slice(0, k);\n};\n\n/**\n * 选择排序，找前k个\n * @param {number[]} arr\n * @param {number} k\n * @return {number[]}\n */\nvar getLeastNumbers = function (arr, k) {\n    if (k < arr.length / 2) {\n        for (let i = 0; i < k; i++) {\n            //每次找到最小的，换到最前面\n            for (let j = i + 1; j < arr.length; j++) {\n                //比较 i j，i 小继续，j小交换\n                if (arr[i] > arr[j]) {\n                    let temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    } else {\n        //选择最大的len - k 个\n        //剩余的就是\n        let len = arr.length;\n        for (let i = len; i > k - 1; i--) {\n            //每次找到最大的，换到最后\n            for (let j = i - 1; j >= 0; j--) {\n                //比较 i j\n                if (arr[i] < arr[j]) {\n                    let temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    }\n    return arr.slice(0, k);\n};\n\n/**\n * 快速排序 n\n * @param {number[]} arr\n * @param {number} k\n * @return {number[]}\n */\n// var getLeastNumbers = function (arr, k) {\n//     if(k === 0 || arr.length === 0) return [];\n\n//     // eslint-disable-next-line no-debugger\n//     debugger\n//     return quickSearch(arr, 0, arr.length - 1)\n\n//     function quickSearch(arr, l, r) {\n//         let p = partition(arr, 0, arr.length - 1);\n//         if(p === k) {\n//             return arr.slice(0, k);\n//         } else if(p < k) {\n//             return quickSearch(arr, p + 1, r);\n//         } else {\n//             return quickSearch(arr, l, p - 1);\n//         }\n//     }\n    \n//     // 切分 返回参考元素下标\n//     function partition(arr, l, r) {\n//         let par = arr[l]; //参考元素\n//         let i = l + 1;\n//         let j = r;\n//         while(i < j) {\n//             //找到左边第一个大于par\n//             while(i < r && arr[i] <= par) i++;\n//             //找到右边第一个小于par\n//             while(j > l && arr[j] >= par) j--;\n//             if(i >= j) {\n//                 break;\n//             }\n//             //交换\n//             const temp = arr[i];\n//             arr[i] = arr[j];\n//             arr[j] = temp;\n//         }\n//         //把做左侧的参考元素放到中间\n//         arr[l] = arr[j];\n//         arr[j] = par;\n\n//         //返回参考元素下标\n//         return j;\n//     }\n// };\n\nexport default {\n    func: () => {\n        let a = [2, 1, 3, 5, 2, 4, 1, 6, 2]\n        const res = getLeastNumbers(a, 5)\n        console.log(res);\n        return `getLeastNumbers ${a} : ${res}`;\n    },\n    title: '40. 最小的k个数',\n    file: \"leetcode_js/getLeastNumbers.js\",\n}","/**\n * 365. 水壶问题\n * 有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？\n\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。\n\n你允许：\n\n装满任意一个水壶\n清空任意一个水壶\n从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/water-and-jug-problem\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n */\n/**\n * 暴力法\n * 经过演算，发现x,y之间，假设y > x，则每次n = y - x, 如果剩余大于x则继续n - x，小于x则，用y减去x-n\n * 每次计算，如果n不存在结果数组，则把结果存进来，如果n存在于数组则结束\n * 结果数组就是所有的可能性\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @return {boolean}\n */\nvar canMeasureWater = function(x, y, z) {\n\n    let big = x + y;\n    let small = Math.min(x, y);\n    let res = [0, small, big];\n    let t = calc(big, small);\n    while(!res.includes(t)) {\n        res.push(t);\n        t = calc(t, small);\n    }\n    return res.includes(z);\n\n    function calc(a, b) {\n        if(a >= b) {\n            return a - b;\n        } else {\n            return big - (b - a);\n        }\n    }\n};\n\n/**\n * 验算推测\n * 假设x小，y大\n * 如果y 是x的倍数，那么，只能算出来x的倍数\n * 如果x,y都是偶数，那么能算出<=y的所有偶数\n * 其他情况，能算出来<= x + y的所有数字\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @return {boolean}\n */\nvar canMeasureWater2 = function(x, y, z) {\n    let big = Math.max(x, y)\n    let small = x > y? Math.min(x - y, y) : Math.min(y - x, x);\n\n    if(z > x + y) return false;\n\n    if(big % small === 0) {\n        return z % small === 0;\n    } else if(big % 2 === 0 && small % 2 === 0) {\n        return z % 2 === 0;\n    } else {\n        return true;\n    }\n};\n\n/**\n * 看了官方题解，数学的力量真厉害\n * 贝祖定理 最大公约数\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @return {boolean}\n */\nvar canMeasureWater3 = function(x, y, z) {\n    if(z > x + y) return false;\n    if(x === 0 || y === 0) return z === 0 || z === x + y;\n    return z % gcd(x, y) === 0;\n    function gcd(x, y) {\n        if(x > y) {\n            return x % y === 0? y : gcd(y, x %y);\n        } else {\n            return y % x === 0? x : gcd(x, y %x);\n        }\n    }\n};\n\nexport default {\n    func: () => {\n        const a = [6, 9, 1]\n        const res = canMeasureWater(...a);\n        const res2 = canMeasureWater2(...a);\n        console.log(res);\n        return `canMeasureWater ${a} func1: ${res}  func2: ${res2}`;\n    },\n    title: '365. 水壶问题',\n    file: \"leetcode_js/canMeasureWater.js\",\n    leetLink: 'https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/'\n}","/**\n * 876. 链表中间点\n * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。\n * 如果有两个中间结点，则返回第二个中间结点。\n * \n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n * 创建一个数组，遍历，保存所有node的引用，返回length / 2的\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n    let list = [head];\n\n    while (head.next) {\n        head = head.next;\n        list.push(head);\n    }\n    console.log(list);\n    return list[Math.floor(list.length / 2)];\n};\n\n/**\n * 根据官方题解，快慢指针\n * @param {ListNode} head \n * @return {ListNode}\n */\nvar middleNode = function (head) {\n    let fast = head;\n    let slow = head;\n\n    while(fast && fast.next) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n\n    return slow;\n}\n\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nlet h1 = new ListNode(1);\nh1.next = new ListNode(2);\nh1.next.next = new ListNode(3);\nh1.next.next.next = new ListNode(4);\nh1.next.next.next.next = new ListNode(5);\n\nexport default {\n    func: () => {\n        let res = middleNode(h1);\n\n        return `链表中间点 ${res.val}`\n\n    },\n    title: '876. 链表中间点',\n    file: \"leetcode_js/middleNode.js\",\n    leetLink: \"https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/fu-zhu-shu-zu-by-egerton/\"\n}","/**\n * 226. 翻转二叉树\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 深度遍历，对每个节点的left, right进行调换\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    \n    if(root === null) return null;\n\n    let temp = root.right;\n    root.right = root.left;\n    root.left = temp;\n\n    invertTree(root.left);\n    invertTree(root.right);\n\n    return root;\n};\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(3);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(5);\nroot1.right.right = new TreeNode(6);\nroot1.right.left = new TreeNode(4);\nroot1.right.right.right = new TreeNode(7);\n\nexport default {\n    func: () => {\n        let res = invertTree(root1);\n        console.log(res);\n        return `翻转二叉树 ${JSON.stringify(res)}`;\n    },\n    title: `226. 翻转二叉树`,\n    file: \"leetcode_js/invertTree.js\",\n}\n\n\n","/**\n * 96. 不同的二叉搜索树\n * 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n * https://leetcode-cn.com/problems/unique-binary-search-trees/\n * \n * 思路：1..n的二叉搜索树数量 = 1为根节点的1..n的二叉搜索数量 + 2为根节点 + 3为根节点 + 4 ... n\n * 而 1为根节点1..n的二叉搜索树数量 = 1 * n - 1个元素的数量\n * 2为根节点1..n的二叉搜索树数量 = 左边1个元素的数量 * 右边n - 2个元素数量\n * 3为根节点1..n数量 = 左边2元素数量 * 右边 n - 3数量\n * 4为根 = 左3数量 * 右n-4数量\n * 可以递归\n * \n * 利用了动态规划，加了个results，效率内存都大大提升。\n * \n * @param {number} n\n * @return {number}\n */\nlet results = [];\nvar numTrees = function(n) {\n    if(n === 1 || n === 0) return 1;\n    if(results[n]) {\n        return results[n];\n    }\n\n    let res = 0;\n    //1 .. n个根相加\n    for(let i = 1; i <= n; i++) {\n        res += numTrees(i - 1) * numTrees(n - i);\n    }\n    results[n] = res;\n\n    return res;\n};\n\nexport default {\n    func: () => {\n        const n = 10;\n        let res = numTrees(n);\n        console.log(res);\n\n        return `1 .. ${n}可以组成的二叉搜索树数量： ${res}`\n    },\n    title: '96. 不同的二叉搜索树',\n    file: \"leetcode_js/numTrees.js\",\n    leetLink: \"https://leetcode-cn.com/problems/unique-binary-search-trees/solution/di-gui-you-hua-by-egerton/\",\n}","import isValidBST from '../leetcode_js/isValidBST';\nimport longestPalindrome2 from '../leetcode_js/longestPalindrome2';\nimport maxDepth from '../leetcode_js/maxDepth';\nimport isRectangleOverlap from '../leetcode_js/isRectangleOverlap';\nimport countChars from '../leetcode_js/countChars';\nimport compressString from '../leetcode_js/compressString';\nimport majorityElement from '../leetcode_js/majorityElement';\nimport gcdOfStrings from '../leetcode_js/gcdOfStrings';\nimport canThreePartsEqualSum from '../leetcode_js/canThreePartsEqualSum';\nimport isSameTree from '../leetcode_js/isSameTree';\nimport candies2 from '../leetcode_js/candies2';\nimport findContinuousSequence from '../leetcode_js/findContinuousSequence';\nimport preorderTraversal from '../leetcode_js/preorderTraversal';\nimport atoi from '../leetcode_js/myAtoi';\nimport flatten from '../leetcode_js/flatten';\nimport longestPalindrome from '../leetcode_js/longestPalindrome';\nimport reverseLinkedList from '../leetcode_js/reverseLinkedList';\nimport mirrorTree from '../leetcode_js/mirrorTree';\nimport maxProfit from '../leetcode_js/maxProfit';\nimport diameterOfBinaryTree from '../leetcode_js/diameterOfBinaryTree';\nimport getLeastNumbers from '../leetcode_js/getLeastNumbers';\nimport canMeasureWater from '../leetcode_js/canMeasureWater';\nimport middleNode from '../leetcode_js/middleNode';\nimport invertTree from '../leetcode_js/invertTree';\nimport surfaceArea from '../leetcode_js/surfaceArea';\nimport numRookCaptures from '../leetcode_js/numRookCaptures';\nimport numTrees from '../leetcode_js/numTrees';\n\nexport default [\n    flatten,\n    atoi,\n    longestPalindrome,\n    reverseLinkedList,\n    mirrorTree,\n    maxProfit,\n    diameterOfBinaryTree,\n    preorderTraversal,\n    findContinuousSequence,\n    candies2,\n    isSameTree,\n    canThreePartsEqualSum,\n    gcdOfStrings,\n    majorityElement,\n    compressString,\n    countChars,\n    isRectangleOverlap,\n    maxDepth,\n    longestPalindrome2,\n    isValidBST,\n    getLeastNumbers,\n    canMeasureWater,\n    middleNode,\n    invertTree,\n    surfaceArea,\n    numRookCaptures,\n    numTrees,\n]","/**\n * 892. 三维形体的表面积\n * 在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。\n\n每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。\n\n请你返回最终形体的表面积。\n例如：\n输入：[[1,2],[3,4]]\n输出：34\n\n在0,1的位置1个block，0,2的位置2层, 1,0的位置3层, 1,1的位置4层\n共 34个面\n */\n/**\n * 表面积 = block个数 * 6 - 2 * 贴合的面数字\n * 那么，遍历一遍，计算block个数，同时计算贴合面数字\n * 计算即可\n * @param {number[][]} grid\n * @return {number}\n */\nvar surfaceArea = function(grid) {\n    let blocks = 0;\n    let faces = 0;\n\n    //遍历多维数组，双循环\n    for(let i = 0; i < grid.length; i++) {\n        //行\n        for(let j = 0; j < grid[i].length; j++) {\n            //高度\n            const h = grid[i][j];\n            blocks += h;\n            //贴合的面数\n            faces += h > 0? h - 1 : 0;\n            faces += j > 0? Math.min(grid[i][j - 1], h) : 0;\n            faces += i > 0? Math.min(grid[i - 1][j], h) : 0;\n        }\n    }\n\n    return blocks * 6 - 2 * faces;\n};\n\nexport default {\n    func: () => {\n        let str1 = [[1,2], [3, 4]]\n        const res = surfaceArea(str1);\n        console.log(res);\n        return `surfaceArea: ${res}`;\n    },\n    title: '892. 三维形体的表面积',\n    file: \"leetcode_js/surfaceArea.js\",\n    leetLink: \"https://leetcode-cn.com/problems/surface-area-of-3d-shapes/solution/kuai-ji-suan-by-egerton/\"\n}","/**\n * 999. 车的可用捕获量\n * 给定一个二维数组棋盘，有一个格子是R车，看它上下左右能不能吃到p卒子，返回能吃到的数量\n */\n/**\n * 找到R的位置\n * 向4个方向寻找，找到第一个非.看是否是p，直到边界\n * @param {character[][]} board\n * @return {number}\n */\nvar numRookCaptures = function (board) {\n    let res = 0;\n    let R = [];\n    const len = 8;\n    forR: for (let i = 0; i < len; i++) {\n        for (let j = 0; j < len; j++) {\n            if (board[i][j] === 'R') {\n                R = [i, j];\n                break forR;\n            }\n        }\n    }\n\n    console.log(R);\n    //left\n    left: for (let j = R[1]; j >= 0; j--) {\n        const c = board[R[0]][j];\n        if (c !== '.' && c !== 'R') {\n            if (c === 'p') {\n                res++;\n                break left;\n            } else {\n                break left;\n            }\n        }\n    }\n\n    //right\n    right: for (let j = R[1]; j < len; j++) {\n        const c = board[R[0]][j];\n        if (c !== '.' && c !== 'R') {\n            if (c === 'p') {\n                res++;\n                break right;\n            } else {\n                break right;\n            }\n        }\n    }\n\n    //top\n    top: for(let i = R[0]; i >= 0; i--) {\n        const c = board[i][R[1]];\n        if (c !== '.' && c !== 'R') {\n            if (c === 'p') {\n                res++;\n                break top;\n            } else {\n                break top;\n            }\n        }\n    }\n\n    //bottom\n    bottom: for(let i = R[0]; i < len; i++) {\n        const c = board[i][R[1]];\n        if (c !== '.' && c !== 'R') {\n            if (c === 'p') {\n                res++;\n                break bottom;\n            } else {\n                break bottom;\n            }\n        }\n    }\n\n    return res;\n};\nexport default {\n    func: () => {\n        let str1 = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n        const res = numRookCaptures(str1);\n        console.log(res);\n        return `numRookCaptures: ${res}`;\n    },\n    title: '999. 车的可用捕获量',\n    file: \"leetcode_js/numRookCaptures.js\",\n}","import React, { useState } from 'react';\nimport './style.sass';\nimport leetcodeList from '../leetcode_js/index';\n\nconst urlPrefix = 'https://github.com/andycao/algorithmLearn/blob/master/src/'\nfunction TaskList() {\n    const [result, setResult] = useState();\n\n    return <><ul>\n        {leetcodeList.map((entry, index) => {\n            return <LinkNew\n            key={index}\n            setResult={setResult}\n            answer={entry}\n        ></LinkNew>\n        })}\n    </ul>\n        <div className=\"result\">\n            {result}\n        </div>\n    </>;\n}\n\nfunction LinkNew(props) {\n    const {answer, setResult} = props;\n    return <li>\n        <span>{answer.title}</span>\n        <span className=\"link\" onClick={() => {\n            window.open(urlPrefix + answer.file)\n        }}>源码</span>\n        <span className=\"link\" onClick={()=>{\n            //run func and set result\n            setResult(answer.func());\n        }}>运行</span>\n        {answer.leetLink?<span className=\"link\" onClick={() => {\n            window.open(answer.leetLink)\n        }}>leetcode题解</span> : null}\n    </li>;\n}\n\nfunction Link(props) {\n    return <li>\n        <span>{props.title}</span>\n        <span className=\"link\" onClick={() => {\n            window.open(urlPrefix + props.file)\n        }}>源码</span>\n        <span className=\"link\" onClick={()=>{\n            //run func and set result\n            props.setResult(props.func());\n        }}>运行</span>\n        {props.leetLink?<span className=\"link\" onClick={() => {\n            window.open(props.leetLink)\n        }}>leetcode题解</span> : null}\n    </li>;\n}\n\nexport default TaskList;","import React from 'react';\nimport Header from './pages/header';\nimport TaskList from './pages/list';\n\nclass App extends React.Component {\n    componentDidMount(){\n        document.title = \"Andy的算法学习\";\n    }\n    render(){\n        return (<div className='container'>\n            <Header />\n            <TaskList />\n        </div>);\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}