{"version":3,"sources":["pages/header.js","leetcode_js/isValidBST.js","leetcode_js/longestPalindrome2.js","leetcode_js/maxDepth.js","leetcode_js/isRectangleOverlap.js","leetcode_js/countChars.js","leetcode_js/compressString.js","leetcode_js/majorityElement.js","leetcode_js/gcdOfStrings.js","leetcode_js/canThreePartsEqualSum.js","leetcode_js/isSameTree.js","leetcode_js/candies2.js","leetcode_js/findContinuousSequence.js","leetcode_js/preorderTraversal.js","leetcode_js/myAtoi.js","leetcode_js/flatten.js","leetcode_js/longestPalindrome.js","leetcode_js/reverseLinkedList.js","leetcode_js/mirrorTree.js","leetcode_js/maxProfit.js","leetcode_js/diameterOfBinaryTree.js","leetcode_js/getLeastNumbers.js","leetcode_js/canMeasureWater.js","leetcode_js/middleNode.js","leetcode_js/invertTree.js","leetcode_js/surfaceArea.js","leetcode_js/numRookCaptures.js","leetcode_js/numTrees.js","leetcode_js/hasGroupsSizeX.js","leetcode_js/minimumLengthEncoding.js","leetcode_js/findLucky.js","leetcode_js/numTeams.js","leetcode_js/maxDistance.js","leetcode_js/lastRemaining.js","leetcode_js/sortArray.js","leetcode_js/maxDepthAfterSplit.js","leetcode_js/gameOfLife.js","leetcode_js/rotate.js","leetcode_js/trap.js","leetcode_js/LFUCache.js","leetcode_js/movingCount.js","leetcode_js/generateParenthesis.js","leetcode_js/addTwoNumbers.js","leetcode_js/jump.js","leetcode_js/index.js","leetcode_js/mySqrt.js","leetcode_js/reversePairs.js","leetcode_js/mergeArray.js","leetcode_js/lengthOfLongestSubstring.js","leetcode_js/maxSubArray.js","pages/list.js","App.js","serviceWorker.js","index.js"],"names":["Header","props","href","target","style","marginLeft","onClick","e","preventDefault","changeOrder","isValidBST","root","left","right","val","maxVal","Number","MAX_SAFE_INTEGER","minVal","prev","MIN_SAFE_INTEGER","res","inorder","node","TreeNode","this","root1","func","console","log","title","file","leetLink","s","len","chars","Set","has","delete","add","size","longestPalindrome2","maxDepth","Math","max","isRangeOverlap","a","b","length","rec1","rec2","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","isRectangleOverlap","parseWordToMap","str","map","Map","set","get","test","map1","map2","keys","k","words","known","total","word","countCharacters","S","temp","num","i","charAt","compressString","nums","lists","maxNum","maxEl","majorityElement","isGcd","x","RegExp","gcd","num1","num2","tmp","str1","str2","len1","len2","gcdNum","substr","gcdOfStrings","sum","array","j","index","A","canThreePartsEqualSum","root2","isSameTree","p","q","candies","num_people","Array","fill","distributeCandies","JSON","stringify","result","l","r","mid","ceil","push","findContinuousSequence","preorderTraversal","pop","trim","exec","parseInt","myAtoi","flatten","reduce","acc","concat","isArray","findLongestAround","out","floor","longestPalindrome","reverseList","head","newHead","next","reverse","pre","cur","ListNode","h1","old","newH","list","shift","isSymmetric","prices","minPrice","v","maxProfit","maxRadius","findDepth","leftDepth","rightDepth","diameterOfBinaryTree","arr","slice","getLeastNumbers","canMeasureWater","y","z","big","small","min","t","calc","includes","canMeasureWater2","res2","fast","slow","middleNode","invertTree","grid","blocks","faces","h","surfaceArea","board","R","forR","c","top","bottom","numRookCaptures","results","numTrees","n","Error","deck","filter","hasGroupsSizeX","collect","minimumLengthEncoding","findLucky","rating","count","numTeams","dist","extend","newDist","maxDistance","m","splice","lastRemaining","sortArray3","quickSort","swap","divide","maxDepthAfterSplit","seq","findMaxDeep","amax","copy","gameOfLife","matrix","x1","y1","x2","y2","rotate","height","maxIndex","curr","trap","LFUCache","capacity","capa","timer","prototype","key","undefined","times","lastDate","value","put","smallestKey","smallest","obj","cache","movingCount","judge","generate","generateParenthesis","h2","jump","Infinity","minStep","end","steps","maxPos","ans","mySqrt","atoi","reverseLinkedList","mirrorTree","candies2","countChars","sortArray","l1","l2","stack1","stack2","addTwoNumbers","reversePairs","B","mergeArray","maxLen","valid","start","lengthOfLongestSubstring","maxSubArray","Quest","answer","stageSelf","showAns","useState","setResult","className","window","open","TaskList","stageIndex","setStageIndex","isFirstRun","useRef","leetcodeList","entry","shortid","sort","reg","match","setList","useEffect","current","order","bind","App","setOrder","document","Boolean","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.71041588.chunk.js","sourcesContent":["import React from \"react\";\nfunction Header(props) {\n    return (\n        <div>\n            <h2>算法学习记录</h2>\n            <p>根据题号，或者leetcode题解，找到原问题</p>\n            <p>\n                <a href=\"https://leetcode-cn.com/u/egerton/\" target=\"blank\">\n                    我的Leetcode\n                </a>\n\n                <a\n                    style={{ marginLeft: \"10px\" }}\n                    href=\"#\"\n                    onClick={(e) => {\n                        e.preventDefault();\n                        props.changeOrder();\n                    }}\n                >\n                    反转顺序\n                </a>\n            </p>\n            <hr></hr>\n        </div>\n    );\n}\n\nexport default Header;\n","/**\n * 98. 验证二叉搜索树\n * 给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n * \n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 如果一个树是bst，那么他的每个节点n的 n.left也是一个bst, n.right也是一个bst\n * 并且n.val > n.left.max, n.val < n.right.min\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function (root) {\n    if (root === null) return true;\n\n    return isValidBST(root.left) && isValidBST(root.right) && root.val > maxVal(root.left) &&\n        root.val < minVal(root.right);\n};\n\n/**\n * 利用中序遍历的读取顺序，只要当前val比上一个val大就可以了\n * 默认值为最小值\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function (root) {\n    let prev = Number.MIN_SAFE_INTEGER;\n    let res = true;\n    inorder(root);\n    return res;\n    function inorder(node) {\n        if (node !== null && res) {\n            inorder(node.left);\n            res = res && node.val > prev;\n            prev = node.val;\n            inorder(node.right);\n        }\n    }\n};\n\n/**\n * 找出一棵bst的max\n * 最右边的值\n * @param {TreeNode} root \n */\nfunction maxVal(root) {\n    if (root === null) return Number.MIN_SAFE_INTEGER;\n    if (root.right) return maxVal(root.right);\n    else return root.val;\n}\n\n/**\n * 找出一棵bst的min\n * 最左边的值\n * @param {TreeNode} root \n */\nfunction minVal(root) {\n    if (root === null) return Number.MAX_SAFE_INTEGER;\n    if (root.left) return maxVal(root.left);\n    else return root.val;\n}\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(3);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(5);\nroot1.right.right = new TreeNode(6);\nroot1.right.left = new TreeNode(4);\nroot1.right.right.right = new TreeNode(7);\n\nexport default {\n    func: () => {\n        let res = isValidBST(root1);\n        console.log(root1);\n        console.log(res);\n        return `验证二叉搜索树 ${res}`;\n    },\n    title: `98. 验证二叉搜索树`,\n    file: \"leetcode_js/isValidBST.js\",\n    leetLink: 'https://leetcode-cn.com/problems/validate-binary-search-tree/solution/shen-du-you-xian-zhong-xu-bian-li-by-egerton/'\n}\n\n\n","/**\n * 409. 最长回文串\n * 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n * 在构造过程中，请注意区分大小写。比如 \"Aa\" 不能当做一个回文字符串。\n * \n*/\n/**\n * 遍历一遍s，使用set保存字母e，\n * 有重复的，长度+2，并去除\n * 不存在，则添加\n * 最后，看set，非空则长度+1\n * @param {string} s\n * @return {number}\n */\nvar longestPalindrome2 = function(s) {\n    let len = 0;\n    let chars = new Set();\n    for(let e of s) {\n        if(chars.has(e)) {\n            len += 2;\n            chars.delete(e);\n        } else {\n            chars.add(e);\n        }\n    }\n\n    if(chars.size !== 0) {\n        len += 1;\n    }\n\n    return len;\n};\nexport default {\n    func: () => {\n        const s = 'aaaaaaaaaaab';\n        let res = longestPalindrome2(s);\n        console.log(res);\n        return `最长回文串 ${s} ${res}`;\n    },\n    title: `409. 最长回文串`,\n    file: \"leetcode_js/longestPalindrome2.js\",\n    leetLink: 'https://leetcode-cn.com/problems/longest-palindrome/solution/bian-li-zi-fu-chuan-by-egerton/'\n}\n\n\n","/**\n * 104. 二叉树的最大深度\n * 给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 后序遍历\n * 当前节点深度 = 子节点最大深度 + 1\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (root === null) return 0;\n\n    const left = maxDepth(root.left);\n    const right = maxDepth(root.right);\n    const dep = Math.max(left, right) + 1;\n    return dep;\n};\n\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\nroot1.right.right = new TreeNode(4);\nroot1.right.right.right = new TreeNode(4);\n\nexport default {\n    func: () => {\n        let res = maxDepth(root1);\n        console.log(root1);\n        console.log(res);\n        return `二叉树的最大深度 ${res}`;\n    },\n    title: `104. 二叉树的最大深度`,\n    leetLink: 'https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/js-hou-xu-bian-li-by-egerton/',\n    file: \"leetcode_js/maxDepth.js\"\n}\n\n\n","/**\n * 836. 矩形重叠\n * 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。\n\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n\n给出两个矩形，判断它们是否重叠并返回结果。\n\n把一个矩形想象成x，y两个范围，当两个矩形的两个范围都有相交的时候，那么这两个矩形重叠\n\n * @param {number[]} rec1\n * @param {number[]} rec2\n * @return {boolean}\n */\nvar isRectangleOverlap = function(rec1, rec2) {\n    let [ax1, ay1, ax2, ay2] = rec1;\n    let [bx1, by1, bx2, by2] = rec2;\n\n    return isRangeOverlap([ax1, ax2], [bx1, bx2]) && isRangeOverlap([ay1, ay2], [by1, by2]);\n};\n\n/**\n * 两个范围是否相交\n * @param {array} a \n * @param {array} b \n */\nfunction isRangeOverlap (a, b){\n    if(a.length !== 2 || b.length !== 2) return false;\n\n    //a 在左边\n    if(a[0] <= b[0]) {\n        return a[1] > b[0];\n    } else {\n        return a[0] < b[1];\n    }\n}\n\nexport default {\n    func: () => {\n        const rec1 = [0,0,2,2];\n        const rec2 = [1,1,3,3];\n\n        const res = isRectangleOverlap(rec1, rec2);\n        console.log(res);\n        return `矩形重叠 ${rec1} ${rec2} : ${res}`;\n    },\n    title: '836. 矩形重叠',\n    file: \"leetcode_js/isRectangleOverlap.js\",\n}","/**\n * 1160. 拼写单词\n * 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n\n    假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n\n    注意：每次拼写时，chars 中的每个字母都只能用一次。\n\n    返回词汇表 words 中你掌握的所有单词的 长度之和。\n */\n/**\n * 把chars转换成map 字母，出现次数\n * 如果words的单词，出现的字母都在map中，并且数量不超过num，那么这个字母是true\n * 返回长度增加word的length\n * @param {string[]} words\n * @param {string} chars\n * @return {number}\n */\nvar countCharacters = function(words, chars) {\n    const known = parseWordToMap(chars);\n    let total = 0;\n\n    for(let word of words) {\n        const map1 = parseWordToMap(word);\n        if(test(map1, known)) {\n            console.log(map1, known);\n            total += word.length;\n        }\n    }\n\n    return total;\n};\n\nfunction parseWordToMap(str) {\n    let map = new Map();\n    for(let s of str) {\n        if(map.has(s)) {\n            map.set(s,map.get(s) + 1);\n        } else {\n            map.set(s, 1);\n        }\n    }\n    return map;\n}\n\n/**\n * map1 included in map2\n * @param {*} map1 \n * @param {*} map2 \n */\nfunction test(map1, map2) {\n    for(let k of map1.keys()){\n        if(!map2.has(k) || map2.get(k) < map1.get(k)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nexport default {\n    func: () => {\n        const words = [\"cat\",\"bt\",\"hat\",\"tree\"];\n        const chars = \"atach\";\n        const res = countCharacters(words, chars);\n        console.log(res);\n        return `拼写单词 ${words} ${chars} : ${res}`;\n    },\n    title: '1160. 拼写单词',\n    file: \"leetcode_js/countChars.js\",\n\n}","/**\n * 01.06 字符串压缩\n * 利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。\n * 比如，字符串aabcccccaaa会变为a2b1c5a3。\n * 若“压缩”后的字符串没有变短，则返回原先的字符串。\n * 你可以假设字符串中只包含大小写英文字母（a至z）。\n */\n/**\n * 遍历，temp暂存，一致num++ 否则组建输出字符串，temp指向新的\n * @param {string} S\n * @return {string}\n */\nvar compressString = function(S) {\n    let res = '';\n    let temp = '';\n    let num = 0;\n    for(let i = 0; i < S.length; i ++) {\n        if(temp === S.charAt(i)) {\n            num++;\n        } else {\n            if(num > 0)\n                res +=  temp + num\n            temp = S.charAt(i);\n            num = 1;\n        }\n    }\n\n    res += temp + num;\n    if(S.length > res.length){\n        return res;\n    } else {\n        return S;\n    }\n};\n\nexport default {\n    func: () => {\n        const str = 'aabcaaaaa';\n        const res = compressString(str)\n        console.log(res);\n        return `compress ${str} : ${res}`;\n    },\n    title: '01.06 字符串压缩',\n    file: \"leetcode_js/compressString.js\",\n}","/**\n * 169. 多数元素\n * 给定一个大小为 n 的数组, 找到其中的多数元素。 多数元素是指在数组中出现次数大于[n/2]的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n维护一个最大值，省去第二次遍历\n */\n\n/**\n * 暴力\n * 使用map存n个数字，遍历，匹配的+1 最后计算长度\n* @param {number[]} nums\n* @return {number}\n*/\nvar majorityElement = function (nums) {\n    let lists = new Map();\n\n    let maxNum = 1;\n    let maxEl = nums[0];\n    for (let e of nums) {\n        if (lists.has(e)) {\n            lists.set(e, lists.get(e) + 1);\n\n            //max\n            if (lists.get(e) > maxNum) {\n                maxEl = e;\n                maxNum = lists.get(e);\n            }\n        } else {\n            lists.set(e, 1);\n        }\n    }\n\n    return maxEl;\n};\n\nexport default {\n    func: () => {\n        let a = [1, 2, 1, 2, 1, 2, 1, 2, 2]\n        const res = majorityElement(a)\n        console.log(res);\n        return `majorityElement ${a} ${res}`;\n    },\n    title: '169. 多数元素',\n    file: \"leetcode_js/majorityElement.js\",\n    leetLink: \"https://leetcode-cn.com/problems/majority-element/solution/js-bao-li-fa-you-hua-by-egerton/\"\n}","/**\n * 1071. 字符串的最大公因子\n * 对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。\n * 返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。\n */\n\n/**\n * 辅助方法，判断x是否为str的公因子，可以使用正则表达式match\n * \n * \n * 根据str1进行切分，1, 1/2, 1/3,....1/n\n * 根据长度判断能否被整除\n * 然后，判断x是否是两个字符串的公因子，第一个match的就是最大的\n * \n * 暴力法\n * \n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar gcdOfStrings = function (str1, str2) {\n    let len1 = str1.length;\n    let len2 = str2.length;\n    if (len1 === 0 || len2 === 0) return '';\n\n    for (let num = 1; num <= len1; num++) {\n        if (len1 % num === 0) {\n            let xLen = len1 / num;\n            if (len2 % xLen === 0) {\n                //判断string\n                let x = str1.substr(0, xLen);\n                if (isGcd(x, str1) && isGcd(x, str2)) {\n                    return x;\n                }\n            }\n        }\n    }\n\n    return '';\n};\n/**\n * 最大公约数 辗转相除法\n * 辅助方法，判断x是否为str的公因子，可以使用正则表达式match\n * 看了题解改成了，最大公约数的方法，跟暴力法相比效率成倍提升\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n *  \n */\nvar gcdOfStrings = function (str1, str2) {\n    let len1 = str1.length;\n    let len2 = str2.length;\n    if (len1 === 0 || len2 === 0) return '';\n\n    let gcdNum = 1;\n    if (len1 > len2) {\n        gcdNum = gcd(len1, len2);\n    } else {\n        gcdNum = gcd(len2, len1);\n    }\n\n    let str = str1.substr(0, gcdNum);\n    if (isGcd(str, str1) && isGcd(str, str2)) {\n        return str1.substr(0, gcdNum);\n    } else {\n        return '';\n    }\n}\n\n//公因子\nfunction isGcd(x, str) {\n    let reg = new RegExp(`^(${x})+$`, 'i');\n    return reg.test(str);\n}\n\n//最大公约数\n//num1 > num2\nfunction gcd(num1, num2) {\n    let tmp = num1 % num2;\n    if (tmp === 0) {\n        return num2;\n    } else {\n        return gcd(num2, tmp)\n    }\n}\n\nexport default {\n    func: () => {\n        let str1 = 'aaaaaaaa';\n        let str2 = 'aaaa';\n        const res = gcdOfStrings(str1, str2);\n        console.log(res);\n        return `gcd of string: ${res}`;\n    },\n    title: '1071. 字符串的最大公因子',\n    file: \"leetcode_js/gcdOfStrings.js\",\n    leetLink: \"https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/solution/qie-fen-zheng-ze-biao-da-shi-by-egerton/\"\n}","/**\n * 1013. 将数组分成和相等的三个部分\n * 给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。\n * 形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。\n * \n * \b\b看例子以及描述，排序是不可变的，那么就用双指针i , j 不停滑动计算判断\n * \n * @param {number[]} A\n * @return {boolean}\n */\nvar canThreePartsEqualSum = function (A) {\n    if (A.length < 3) return false;\n\n    let a = 0, b = 0, c = 0;\n    for (let i = 1; i < A.length - 1; i++) {\n        a += A[i - 1];\n        b = 0;\n        for (let j = i + 1; j < A.length; j++) {\n            b += A[j - 1];\n            if (a === b) {\n                c = sum(A, j, A.length);\n                if (a === c) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\nfunction sum(array, i, j) {\n    let sum = 0;\n    for (let index = i; index < j; index++) {\n        sum += array[index];\n    }\n\n    return sum;\n}\n\nexport default {\n    func: () => {\n        let list = [3, 3, 6, 5, -2, 2, 5, 1, -9, 4]\n        const res = canThreePartsEqualSum(list)\n        console.log(res);\n        return `${res}`;\n    },\n    title: '1013. 数组三等分',\n    file: \"leetcode_js/diameterOfBinaryTree.js\",\n}","/**\n * 100. 相同的树\n * 给定两个二叉树，编写一个函数来检验它们是否相同。\n * 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 先序遍历，二叉树迭代\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n    if (p === null && q === null) return true;\n    if (p === null || q === null) return false;\n\n    return p.val === q.val &&\n        isSameTree(p.left, q.left) &&\n        isSameTree(p.right, q.right);\n};\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\n\nlet root2 = new TreeNode(1);\nroot2.left = new TreeNode(2);\nroot2.right = new TreeNode(3);\n\nexport default {\n    func: () => {\n        let res = isSameTree(root1, root2);\n        console.log(root1, root2, res);\n\n        return `isSame tree ${res}`\n    },\n    title: '100. 相同的树',\n    file: \"leetcode_js/isSameTree.js\",\n    leetLink: 'https://leetcode-cn.com/problems/same-tree/solution/javascript-xian-xu-bian-li-by-egerton/'\n\n}","/**\n * 1103 分糖果2\n * 排排坐，分糖果。\n\n我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。\n\n给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。\n\n然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。\n\n重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。\n\n返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。\n\n \n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/distribute-candies-to-people\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n * 定义一个数组，数组长度n, 顺序给数组的值 +糖果数\n * @param {number} candies\n * @param {number} num_people\n * @return {number[]}\n */\nvar distributeCandies = function(candies, num_people) {\n    let array = new Array(num_people).fill(0);\n\n    let i = 0;\n    let num = 1;\n    while(candies > 0) {\n        if(num > candies) {\n            num = candies;\n        }\n        array[i] += num;\n        candies -= num;\n\n        num += 1;\n        i = ++i % num_people;\n    }\n\n    console.log(array);\n\n    return array;\n    \n};\n\nexport default {\n    func: () => {\n        const res = distributeCandies(16, 3)\n    console.log(res);\n    return JSON.stringify(res);\n    },\n    title: '1103.分糖果2',\n    file: \"leetcode_js/candies2.js\",\n    leetLink: \"https://leetcode-cn.com/problems/distribute-candies-to-people/solution/js-shu-zu-by-egerton/\"\n}","/**\n * 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n示例 1：\n\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n示例 2：\n\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n \n\n限制：\n\n1 <= target <= 10^5\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n * 暴力的方法，1 ~ target / 2，每个数开始，加起来看看是否相等于target\n 小于则继续加，大于则不成立，等于则数组有效\n * @param {number} target\n * @return {number[][]}\n */\nvar findContinuousSequence = function (target) {\n    let result = [];\n    //1\n    if (target === 1) {\n        return result;\n    }\n\n    //从1 开始 到 Math.ceil(target / 2)\n    for (let i = 1; i < Math.ceil(target / 2); i++) {\n        let sum = 0;\n        let acc = i;\n        while (sum <= target) {\n            if (sum < target) {\n                sum += acc++;\n            } else if (sum === target) {\n                //equal array from i ~ acc\n                let array = [];\n                for (let index = i; index < acc; index++) {\n                    array.push(index);\n                }\n\n                result.push(array);\n\n                break;\n            }\n        }\n    }\n\n    return result;\n};\n/*\n* 滑动窗口 \n定义左侧，右侧，l,r  1,2\n计算l ~ r 的和，< target l不变，r可以向右扩展\n= target 则l r组合正确，而且l开头的组合就这一个保存并且l + 1，r + 1。 \n    l+1 r 的组合肯定小于target。l最远能到target / 2中间\n>target 则l 开头没有正确组合， l + 1, r不变\n当l > target / 2 或l >= r时结束循环，返回结果\n\n* @param {number} target\n* @return {number[][]}\n*/\nvar findContinuousSequence = function (target) {\n    let result = [];\n    if (target === 1) return result;\n    let l = 1;\n    let r = 2;\n\n    let sum = 0;\n    let mid = Math.ceil(target / 2);\n    while (l < mid && l < r) {\n        sum = (l + r) * (r - l + 1) / 2;\n        if (sum < target) {\n            r++;\n        } else if (sum === target) {\n            let array = [];\n            for (let index = l; index <= r; index++) {\n                array.push(index);\n            }\n            result.push(array);\n\n            l++;\n            r++;\n        } else {\n            l++;\n        }\n    }\n\n    return result;\n}\n\nexport default {\n    func: () => {\n        const res = findContinuousSequence(15)\n        console.log(res);\n        return JSON.stringify(res);\n    },\n    title: '57 - II 连续正整数序列',\n    file: \"leetcode_js/findContinuousSequence.js\",\n    leetLink: \"https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/javascript-shuang-zhi-zhen-hua-dong-chuang-kou-by-/\"\n}","/**\n * 144.给定一个二叉树，返回它的 先序 遍历。\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 递归的方法，先访问本节点value，再访问左节点，再右节点\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n    let result = [];\n    if (root !== null) {\n        result.push(root.val);\n        result.push(...preorderTraversal(root.left));\n        result.push(...preorderTraversal(root.right));\n    }\n    return result;\n};\n\n/**\n * 迭代的方法\n * 拿到一个节点，检查是否为null\n * 非null, 保存值，添加到暂存栈，指向它的left\n * null，则从栈里pop出来一个node，并且指向它的right\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n    let result = [];\n\n    //暂存\n    let temp = [];\n\n    //检查的node\n    let node = root;\n\n    while (node !== null || temp.length > 0) {\n\n        if (node !== null) {\n            result.push(node.val);\n            temp.push(node);\n            node = node.left;\n        } else {\n            node = temp.pop().right\n        }\n    }\n    return result;\n};\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\n/**\n *         1\n       /        \\\n     2           2\n   /   \\       /   \\\n  3     4     4     3\n */\nlet root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(2);\nroot.left.left = new TreeNode(3);\nroot.right.right = new TreeNode(3);\nroot.left.right = new TreeNode(4);\nroot.right.left = new TreeNode(4);\n\nexport default {\n    func: () => {\n        let res = preorderTraversal(root);\n        console.log(res);\n\n        return `先序遍历 ${JSON.stringify(res)}`;\n    },\n    title: '144. 二叉树先序遍历',\n    file: \"leetcode_js/preorderTraversal.js\",\n    leetLink: \"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/di-gui-zan-cun-zhan-by-egerton/\"\n}","/**\n * 8. 字符串转换整数 (atoi)\n * @param {string} str\n * @return {number}\n */\nlet max = 2147483648 - 1;\nlet min = -2147483648;\nvar myAtoi = function (str) {\n    let s = str.trim();\n\n    let reg = /^[+-]?\\d+/;\n    let res = reg.exec(s);\n    if (res) {\n        let num = parseInt(res[0]);\n        if (num > max) return max;\n        else if (num < min) return min;\n        else return num;\n    } else {\n        return 0;\n    }\n};\n\nexport default {\n    func: () => {\n        const res = myAtoi('-91283472332-=')\n        console.log(res);\n\n        return `${res}`;\n    },\n    title: '8. 字符串转换整数',\n    file: \"leetcode_js/myAtoi.js\",\n}","// const flatten = function (array) {\n//     let result = [];\n//     for(let e of array) {\n//         if(Array.isArray(e)) {\n//             result.push(...flatten(e))\n//         } else {\n//             result.push(e)\n//         }\n//     }\n//     return result;\n// }\n\nconst flatten = function (array) {\n    return array.reduce(\n        (acc, val) => acc.concat(Array.isArray(val) ? flatten(val) : val),\n        [])\n}\n\n\nexport default {\n    func: () => {\n        const res = flatten([1, 2, 3, [4, 5, 6, [7, 8]]])\n        console.log(res);\n\n        return `${res}`;\n    },\n    title: '手写flat',\n    file: \"leetcode_js/flatten.js\",\n}","/* eslint-disable no-unused-vars */\n/**\n * 5. 最长回文子串\n * 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n\n    let res = '';\n\n    for (let i = 0; i < s.length; i++) {\n        let len1 = findLongestAround(s, i, i); //奇数\n        let len2 = findLongestAround(s, i, i + 1) //偶数\n        let len = Math.max(len1, len2);\n        if(len > res.length) {\n            res = s.substr(i - Math.floor((len - 1) / 2), len);\n        }\n    }\n\n    return res;\n};\n\nfunction testPalindrome(str) {\n    let reverse = [...str].reverse().join('');\n    return reverse === str;\n}\n\nfunction testPal(str, i, j) {\n    while(i < j) {\n        if(str.charAt(i) !== str.charAt(j)){\n            return false\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n\nfunction findLongestAround(str, left, right) {\n\n    while (left >= 0 && right < str.length && str.charAt(left) === str.charAt(right)) {\n        left--;\n        right++;\n    }\n    return right - left - 1\n}\n\nconst longestPalindromeViolence = function (str) {\n    const len = str.length;\n    if(len < 2) {\n        return str;\n    }\n\n    let res = str.substr(0, 1);\n    for (let i = 0; i < len; i++) {\n        for(let j = i; j < len; j++) {\n            if(j - i + 1 > res.length && testPal(str, i, j)) {\n                res = str.substr(i, j - i + 1);\n            }\n        }\n    }\n\n    return res;\n}\n\nexport default {\n    func: () => {\n        let input = 'abcabcabcabccedabbac'\n        let out = longestPalindrome(input)\n        console.log(out);\n\n        return `最长回文子串 ${out}`;\n    },\n    title: '5. 最长回文子串',\n    file: \"leetcode_js/longestPalindrome.js\",\n}","/**\n * 反转链表\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * 迭代的方法\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    let newHead = null;\n    let temp = head;\n    while (temp) {\n        temp = head.next;\n        head.next = newHead;\n        newHead = head;\n        head = temp;\n    }\n\n    return newHead;\n};\n\n\n/**\n * 递归的方法\n * 反向递归\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    if (head == null || head.next == null)\n        return head;\n\n    let res = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n\n    return res;\n};\n\nvar reverseList = (head) => {\n    // debugger\n    let reverse = (pre, cur) => {\n        if (!cur) return pre;\n        // 保存 next 节点\n        let next = cur.next;\n        cur.next = pre;\n        return reverse(cur, next);\n    }\n    return reverse(null, head);\n}\n\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nlet h1 = new ListNode(1);\nh1.next = new ListNode(2);\nh1.next.next = new ListNode(3);\nh1.next.next.next = new ListNode(4);\n\n\nexport default {\n    func: () => {\n        let old = JSON.stringify(h1);\n    let newH = reverseList(h1);\n    console.log('old', old);\n    console.log('new', newH);\n\n    return JSON.stringify(newH)\n\n    },\n    title: '反转链表',\n    file: \"leetcode_js/reverseLinkedList.js\",\n}","/* eslint-disable no-redeclare */\n/**\n * 101 给定一个二叉树，检查它是否是镜像对称的。\n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n           1\n       /        \\\n     2           2\n   /   \\       /   \\\n  3     4     4     3\n / \\   / \\   / \\   / \\\n5   6 7   8 8   7 6   5\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/symmetric-tree\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 递归的方法，如果两个树是镜像树的话，那么他们的值相等，并且一个的左边，与另一个的右边互为镜像树\n * 一个的右边与另一个的左边互为镜像树\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n    return isMirror(root, root);\n};\n\nfunction isMirror(nodeLeft, nodeRight) {\n    if (nodeLeft === null && nodeRight === null) {\n        return true;\n    } else if (nodeLeft === null || nodeRight === null) {\n        return false;\n    } else if (nodeLeft.val === nodeRight.val &&\n        isMirror(nodeLeft.left, nodeRight.right) &&\n        isMirror(nodeLeft.right, nodeRight.left)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * 递归，除了root向队列里推左右两边，shift出来2个元素，比较相同。如果相等，继续推两个元素的左边，右边一对，右边，左边一对\n * 不相等时退出，两个元素同为null时退出\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n    if(root === null) return true;\n    let list = [root.left, root.right];\n    \n    while(list.length > 0) {\n        let a = list.shift();\n        let b = list.shift();\n\n        if(a === null && b == null) {\n            continue;\n        } else if(a === null || b === null) {\n            return false;\n        } else if(a.val === b.val) {\n            list.push(a.left, b.right);\n            list.push(a.right, b.left);\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(2);\nroot.left.left = new TreeNode(3);\nroot.right.right = new TreeNode(3);\nroot.left.right = new TreeNode(4);\nroot.right.left = new TreeNode(4);\n\nexport default {\n    func: () => {\n        let res = isSymmetric(root);\n        console.log(res);\n\n        return `isSymmetric ${res}`\n    },\n    title: '101. 镜像二叉树',\n    file: \"leetcode_js/mirrorTree.js\",\n}","/* eslint-disable no-redeclare */\n/**\n * 121. 买卖股票的最佳时机\n * 给定一个数组, 它的第 i 个元素是一支给定股票第 i 天的价格。\n\n    如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n\n * 注意你不能在买入股票前卖出股票。\n * 根据原数组，(n + 1)  - n 创建一个变化数组,计算变化数组的最大段，最大值\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n    let max = 0;\n    if (prices.length === 0) return max;\n\n    let accList = prices.map((val, index, array) => {\n        if (index === array.length - 1) {\n            return 0;\n        } else {\n            let temp = array[index + 1] - val;\n            return temp;\n        }\n    });\n\n    max = Math.max(...accList);\n\n    //计算区间 max\n    for (let i = 0; i < accList.length; i++) {\n        let sum = 0;\n        //优化：只有最左边，或者，左侧值<0时\n        if (i === 0 || accList[i - 1] < 0) {\n            for (let j = i; j < accList.length; j++) {\n                sum += accList[j];\n                max = Math.max(max, sum);\n            }\n        }\n    }\n\n    return max;\n};\n\n//保存历史最低价，一次遍历\nvar maxProfit = function (prices) {\n    let max = 0;\n    if (prices.length === 0) return max;\n    let minPrice = prices[0];\n    for (let v of prices) {\n        if (v < minPrice) {\n            minPrice = v;\n        } else {\n            if (v - minPrice > max) {\n                max = v - minPrice;\n            }\n        }\n    }\n\n    return max;\n}\n\nexport default {\n    func: () => {\n        // let list = [2,1,2,0,1];\n    let list = [2, 1, 2, 0, 1, 5, 4, 1, 6];\n    let res = maxProfit(list);\n    console.log(res);\n\n    return JSON.stringify(`max profit: ${res}`);\n    },\n    title: '121. 买卖股票的最佳时机',\n    file: \"leetcode_js/maxProfit.js\",\n}","/**\n * 543.二叉树的直径\n * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。\n * \n * 一个树经过root节点的直径，就是它左侧的深度 L 右侧的深度 R  + 1\n * 那么，在经过所有节点的直径中，找到最大值就可以了\n * 后序，深度遍历\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nlet diameterOfBinaryTree = function (root) {\n    //在作用域内保存变量\n    let maxRadius = 0;\n    findDepth(root);\n    return maxRadius;\n\n    function findDepth(root) {\n        if (root === null) return 0;\n        //max 左侧，右侧\n        let leftDepth = findDepth(root.left);\n        let rightDepth = findDepth(root.right);\n\n        maxRadius = Math.max(maxRadius, leftDepth + rightDepth);\n        return Math.max(leftDepth, rightDepth) + 1\n\n    }\n};\n\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(1);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(3);\nroot1.left.left = new TreeNode(4);\nroot1.left.right = new TreeNode(5);\n// root1.right.left = new TreeNode(6)\n/**\n          1\n         / \\\n        2   3\n       / \\     \n      4   5  \n */\n\nexport default {\n    func: () => {\n        const res = diameterOfBinaryTree(root1)\n        console.log(res);\n        return `直径 ${res}`;\n    },\n    title: '543.二叉树的直径',\n    file: \"leetcode_js/diameterOfBinaryTree.js\",\n}","/**\n * 40. 最小的k个数\n * 输入整数数组 arr ，找出其中最小的 k 个数。\n * 例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n */\n/**\n * 暴力一点，对字符串排序，前k个\n * @param {number[]} arr\n * @param {number} k\n * @return {number[]}\n */\nvar getLeastNumbers = function (arr, k) {\n    arr.sort((a, b) => a - b);\n    return arr.slice(0, k);\n};\n\n/**\n * 选择排序，找前k个\n * @param {number[]} arr\n * @param {number} k\n * @return {number[]}\n */\nvar getLeastNumbers = function (arr, k) {\n    if (k < arr.length / 2) {\n        for (let i = 0; i < k; i++) {\n            //每次找到最小的，换到最前面\n            for (let j = i + 1; j < arr.length; j++) {\n                //比较 i j，i 小继续，j小交换\n                if (arr[i] > arr[j]) {\n                    let temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    } else {\n        //选择最大的len - k 个\n        //剩余的就是\n        let len = arr.length;\n        for (let i = len; i > k - 1; i--) {\n            //每次找到最大的，换到最后\n            for (let j = i - 1; j >= 0; j--) {\n                //比较 i j\n                if (arr[i] < arr[j]) {\n                    let temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    }\n    return arr.slice(0, k);\n};\n\n/**\n * 快速排序 n\n * @param {number[]} arr\n * @param {number} k\n * @return {number[]}\n */\n// var getLeastNumbers = function (arr, k) {\n//     if(k === 0 || arr.length === 0) return [];\n\n//     // eslint-disable-next-line no-debugger\n//     debugger\n//     return quickSearch(arr, 0, arr.length - 1)\n\n//     function quickSearch(arr, l, r) {\n//         let p = partition(arr, 0, arr.length - 1);\n//         if(p === k) {\n//             return arr.slice(0, k);\n//         } else if(p < k) {\n//             return quickSearch(arr, p + 1, r);\n//         } else {\n//             return quickSearch(arr, l, p - 1);\n//         }\n//     }\n    \n//     // 切分 返回参考元素下标\n//     function partition(arr, l, r) {\n//         let par = arr[l]; //参考元素\n//         let i = l + 1;\n//         let j = r;\n//         while(i < j) {\n//             //找到左边第一个大于par\n//             while(i < r && arr[i] <= par) i++;\n//             //找到右边第一个小于par\n//             while(j > l && arr[j] >= par) j--;\n//             if(i >= j) {\n//                 break;\n//             }\n//             //交换\n//             const temp = arr[i];\n//             arr[i] = arr[j];\n//             arr[j] = temp;\n//         }\n//         //把做左侧的参考元素放到中间\n//         arr[l] = arr[j];\n//         arr[j] = par;\n\n//         //返回参考元素下标\n//         return j;\n//     }\n// };\n\nexport default {\n    func: () => {\n        let a = [2, 1, 3, 5, 2, 4, 1, 6, 2]\n        const res = getLeastNumbers(a, 5)\n        console.log(res);\n        return `getLeastNumbers ${a} : ${res}`;\n    },\n    title: '40. 最小的k个数',\n    file: \"leetcode_js/getLeastNumbers.js\",\n}","/**\n * 365. 水壶问题\n * 有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？\n\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。\n\n你允许：\n\n装满任意一个水壶\n清空任意一个水壶\n从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/water-and-jug-problem\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n */\n/**\n * 暴力法\n * 经过演算，发现x,y之间，假设y > x，则每次n = y - x, 如果剩余大于x则继续n - x，小于x则，用y减去x-n\n * 每次计算，如果n不存在结果数组，则把结果存进来，如果n存在于数组则结束\n * 结果数组就是所有的可能性\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @return {boolean}\n */\nvar canMeasureWater = function(x, y, z) {\n\n    let big = x + y;\n    let small = Math.min(x, y);\n    let res = [0, small, big];\n    let t = calc(big, small);\n    while(!res.includes(t)) {\n        res.push(t);\n        t = calc(t, small);\n    }\n    return res.includes(z);\n\n    function calc(a, b) {\n        if(a >= b) {\n            return a - b;\n        } else {\n            return big - (b - a);\n        }\n    }\n};\n\n/**\n * 验算推测\n * 假设x小，y大\n * 如果y 是x的倍数，那么，只能算出来x的倍数\n * 如果x,y都是偶数，那么能算出<=y的所有偶数\n * 其他情况，能算出来<= x + y的所有数字\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @return {boolean}\n */\nvar canMeasureWater2 = function(x, y, z) {\n    let big = Math.max(x, y)\n    let small = x > y? Math.min(x - y, y) : Math.min(y - x, x);\n\n    if(z > x + y) return false;\n\n    if(big % small === 0) {\n        return z % small === 0;\n    } else if(big % 2 === 0 && small % 2 === 0) {\n        return z % 2 === 0;\n    } else {\n        return true;\n    }\n};\n\n/**\n * 看了官方题解，数学的力量真厉害\n * 贝祖定理 最大公约数\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @return {boolean}\n */\nvar canMeasureWater3 = function(x, y, z) {\n    if(z > x + y) return false;\n    if(x === 0 || y === 0) return z === 0 || z === x + y;\n    return z % gcd(x, y) === 0;\n    function gcd(x, y) {\n        if(x > y) {\n            return x % y === 0? y : gcd(y, x %y);\n        } else {\n            return y % x === 0? x : gcd(x, y %x);\n        }\n    }\n};\n\nexport default {\n    func: () => {\n        const a = [6, 9, 1]\n        const res = canMeasureWater(...a);\n        const res2 = canMeasureWater2(...a);\n        console.log(res);\n        return `canMeasureWater ${a} func1: ${res}  func2: ${res2}`;\n    },\n    title: '365. 水壶问题',\n    file: \"leetcode_js/canMeasureWater.js\",\n    leetLink: 'https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/'\n}","/**\n * 876. 链表中间点\n * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。\n * 如果有两个中间结点，则返回第二个中间结点。\n * \n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n * 创建一个数组，遍历，保存所有node的引用，返回length / 2的\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n    let list = [head];\n\n    while (head.next) {\n        head = head.next;\n        list.push(head);\n    }\n    console.log(list);\n    return list[Math.floor(list.length / 2)];\n};\n\n/**\n * 根据官方题解，快慢指针\n * @param {ListNode} head \n * @return {ListNode}\n */\nvar middleNode = function (head) {\n    let fast = head;\n    let slow = head;\n\n    while(fast && fast.next) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n\n    return slow;\n}\n\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nlet h1 = new ListNode(1);\nh1.next = new ListNode(2);\nh1.next.next = new ListNode(3);\nh1.next.next.next = new ListNode(4);\nh1.next.next.next.next = new ListNode(5);\n\nexport default {\n    func: () => {\n        let res = middleNode(h1);\n\n        return `链表中间点 ${res.val}`\n\n    },\n    title: '876. 链表中间点',\n    file: \"leetcode_js/middleNode.js\",\n    leetLink: \"https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/fu-zhu-shu-zu-by-egerton/\"\n}","/**\n * 226. 翻转二叉树\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * 深度遍历，对每个节点的left, right进行调换\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    \n    if(root === null) return null;\n\n    let temp = root.right;\n    root.right = root.left;\n    root.left = temp;\n\n    invertTree(root.left);\n    invertTree(root.right);\n\n    return root;\n};\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nlet root1 = new TreeNode(3);\nroot1.left = new TreeNode(2);\nroot1.right = new TreeNode(5);\nroot1.right.right = new TreeNode(6);\nroot1.right.left = new TreeNode(4);\nroot1.right.right.right = new TreeNode(7);\n\nexport default {\n    func: () => {\n        let res = invertTree(root1);\n        console.log(res);\n        return `翻转二叉树 ${JSON.stringify(res)}`;\n    },\n    title: `226. 翻转二叉树`,\n    file: \"leetcode_js/invertTree.js\",\n}\n\n\n","/**\n * 892. 三维形体的表面积\n * 在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。\n\n每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。\n\n请你返回最终形体的表面积。\n例如：\n输入：[[1,2],[3,4]]\n输出：34\n\n在0,1的位置1个block，0,2的位置2层, 1,0的位置3层, 1,1的位置4层\n共 34个面\n */\n/**\n * 表面积 = block个数 * 6 - 2 * 贴合的面数字\n * 那么，遍历一遍，计算block个数，同时计算贴合面数字\n * 计算即可\n * @param {number[][]} grid\n * @return {number}\n */\nvar surfaceArea = function(grid) {\n    let blocks = 0;\n    let faces = 0;\n\n    //遍历多维数组，双循环\n    for(let i = 0; i < grid.length; i++) {\n        //行\n        for(let j = 0; j < grid[i].length; j++) {\n            //高度\n            const h = grid[i][j];\n            blocks += h;\n            //贴合的面数\n            faces += h > 0? h - 1 : 0;\n            faces += j > 0? Math.min(grid[i][j - 1], h) : 0;\n            faces += i > 0? Math.min(grid[i - 1][j], h) : 0;\n        }\n    }\n\n    return blocks * 6 - 2 * faces;\n};\n\nexport default {\n    func: () => {\n        let str1 = [[1,2], [3, 4]]\n        const res = surfaceArea(str1);\n        console.log(res);\n        return `surfaceArea: ${res}`;\n    },\n    title: '892. 三维形体的表面积',\n    file: \"leetcode_js/surfaceArea.js\",\n    leetLink: \"https://leetcode-cn.com/problems/surface-area-of-3d-shapes/solution/kuai-ji-suan-by-egerton/\"\n}","/**\n * 999. 车的可用捕获量\n * 给定一个二维数组棋盘，有一个格子是R车，看它上下左右能不能吃到p卒子，返回能吃到的数量\n */\n/**\n * 找到R的位置\n * 向4个方向寻找，找到第一个非.看是否是p，直到边界\n * @param {character[][]} board\n * @return {number}\n */\nvar numRookCaptures = function (board) {\n    let res = 0;\n    let R = [];\n    const len = 8;\n    forR: for (let i = 0; i < len; i++) {\n        for (let j = 0; j < len; j++) {\n            if (board[i][j] === 'R') {\n                R = [i, j];\n                break forR;\n            }\n        }\n    }\n\n    console.log(R);\n    //left\n    left: for (let j = R[1]; j >= 0; j--) {\n        const c = board[R[0]][j];\n        if (c !== '.' && c !== 'R') {\n            if (c === 'p') {\n                res++;\n                break left;\n            } else {\n                break left;\n            }\n        }\n    }\n\n    //right\n    right: for (let j = R[1]; j < len; j++) {\n        const c = board[R[0]][j];\n        if (c !== '.' && c !== 'R') {\n            if (c === 'p') {\n                res++;\n                break right;\n            } else {\n                break right;\n            }\n        }\n    }\n\n    //top\n    top: for(let i = R[0]; i >= 0; i--) {\n        const c = board[i][R[1]];\n        if (c !== '.' && c !== 'R') {\n            if (c === 'p') {\n                res++;\n                break top;\n            } else {\n                break top;\n            }\n        }\n    }\n\n    //bottom\n    bottom: for(let i = R[0]; i < len; i++) {\n        const c = board[i][R[1]];\n        if (c !== '.' && c !== 'R') {\n            if (c === 'p') {\n                res++;\n                break bottom;\n            } else {\n                break bottom;\n            }\n        }\n    }\n\n    return res;\n};\nexport default {\n    func: () => {\n        let str1 = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n        const res = numRookCaptures(str1);\n        console.log(res);\n        return `numRookCaptures: ${res}`;\n    },\n    title: '999. 车的可用捕获量',\n    file: \"leetcode_js/numRookCaptures.js\",\n}","/**\n * 96. 不同的二叉搜索树\n * 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n * https://leetcode-cn.com/problems/unique-binary-search-trees/\n * \n * 思路：1..n的二叉搜索树数量 = 1为根节点的1..n的二叉搜索数量 + 2为根节点 + 3为根节点 + 4 ... n\n * 而 1为根节点1..n的二叉搜索树数量 = 1 * n - 1个元素的数量\n * 2为根节点1..n的二叉搜索树数量 = 左边1个元素的数量 * 右边n - 2个元素数量\n * 3为根节点1..n数量 = 左边2元素数量 * 右边 n - 3数量\n * 4为根 = 左3数量 * 右n-4数量\n * 可以递归\n * \n * 利用了动态规划，加了个results，效率内存都大大提升。\n * \n * @param {number} n\n * @return {number}\n */\nlet results = [];\nvar numTrees = function(n) {\n    if(n === 1 || n === 0) return 1;\n    if(results[n]) {\n        return results[n];\n    }\n\n    let res = 0;\n    //1 .. n个根相加\n    for(let i = 1; i <= n; i++) {\n        res += numTrees(i - 1) * numTrees(n - i);\n    }\n    results[n] = res;\n\n    return res;\n};\n\nexport default {\n    func: () => {\n        const n = 10;\n        let res = numTrees(n);\n        console.log(res);\n\n        return `1 .. ${n}可以组成的二叉搜索树数量： ${res}`\n    },\n    title: '96. 不同的二叉搜索树',\n    file: \"leetcode_js/numTrees.js\",\n    leetLink: \"https://leetcode-cn.com/problems/unique-binary-search-trees/solution/di-gui-you-hua-by-egerton/\",\n}","/**\n * 914. 卡牌分组\n * https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/\n给定一副牌，每张牌上都写着一个整数。\n\n此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n\n每组都有 X 张牌。\n组内所有的牌上都写着相同的整数。\n仅当你可选的 X >= 2 时返回 true。\n */\n/**\n * 数出所有数字卡牌的个数\n * 求这一组的最大公约数，如果大于1则返回true，否则false\n * @param {number[]} deck\n * @return {boolean}\n */\nvar hasGroupsSizeX = function(deck) {\n    let list = [];\n    for(let e of deck) {\n        list[e] = list[e] ? list[e]+1 : 1\n    }\n    \n    //去除undefined\n    list = list.filter(e=>e);\n    let gcdNum = list[0];\n    for(let e of list) {\n        gcdNum = gcd(gcdNum, e);\n        if(gcdNum < 2) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nfunction gcd(num1, num2) {\n    if(num2 === 0) throw Error('no 0');\n    let tmp = num1 % num2;\n    if (tmp === 0) {\n        return num2;\n    } else {\n        return gcd(num2, tmp)\n    }\n}\n\nexport default {\n    func: () => {\n        // const n = [1,2,3,4,4,3,2,1];\n        const n = [1]\n        let res = hasGroupsSizeX(n);\n        console.log(res);\n\n        return `hasGroupsSizeX ${n}： ${res}`\n    },\n    title: '914. 卡牌分组',\n    file: \"leetcode_js/hasGroupsSizeX.js\",\n    leetLink: \"https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/solution/bao-li-gcd-by-egerton/\"\n}","/**\n * 820. 单词的压缩编码\n * https://leetcode-cn.com/problems/short-encoding-of-words/\n * 给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。\n例如，如果这个列表是 [\"time\", \"me\", \"bell\"]，我们就可以将其表示为 S = \"time#bell#\" 和 indexes = [0, 2, 5]。\n\n对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 \"#\" 结束，来恢复我们之前的单词列表。\n\n那么成功对给定单词列表进行编码的最小字符串长度是多少呢？\n\n */\n\n/**\n * 对字符串数组list，去重，并且按照长度从大到小排序\n * 辅助函数，包含，检测a，是否包含b\n * 计算最大长度n，遍历数组list，如果能被已有的元素包含，则n - l + 1\n * @param {string[]} words\n * @return {number}\n */\nvar minimumLengthEncoding = function (words) {\n    //去重\n    let list = [...new Set(words)];\n    //从长到短排序\n    list.sort((a, b) => b.length - a.length);\n\n    //总长度\n    let res = 0;\n    for(let e of list) {\n        res += e.length + 1;\n    }\n\n    //判断是否能被压缩\n    for(let i = 0; i < list.length; i++) {\n        let canInclude = false;\n        testInclude: for(let j = i - 1; j >= 0; j--) {\n            canInclude = include(list[j], list[i]);\n            if(canInclude) {\n                //n - l + 1\n                res -= list[i].length + 1;\n                break testInclude;\n            }\n        }\n    }\n\n    return res;\n\n};\n\n/**\n * if a include b\n * b.length <= a.length\n * @param {string} a \n * @param {string} b \n */\nfunction include(a, b) {\n    //undefined\n    if(!a) return false;\n\n    const blen = b.length;\n    const alen = a.length;\n    for(let i = 0; i < blen; i++) {\n        if(b[blen - i - 1] !== a[alen - i - 1]) return false;\n    }\n\n    return true;\n}\n\n/**\n * 官方题解，去除后缀\n * @param {string[]} words\n * @return {number}\n */\nvar minimumLengthEncoding = function (words) {\n    let collect = new Set(words);\n\n    for(let e of collect) {\n        for(let i = 1; i < e.length; i++) {\n            const str = e.slice(i);\n            collect.has(str) && collect.delete(str);\n        }\n    }\n\n    let res = 0;\n    for(let e of collect) {\n        res += e.length + 1;\n    }\n\n    return res;\n}\n\nexport default {\n    func: () => {\n        const n = [\"time\", \"me\", \"bell\", 'ell'];\n        let res = minimumLengthEncoding(n);\n        console.log(res);\n\n        return `单词的压缩编码： ${res}`\n    },\n    title: '820. 单词的压缩编码',\n    file: \"leetcode_js/minimumLengthEncoding.js\",\n}","/**\n * 5368. 找出数组中的幸运数\n * 在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。\n\n给你一个整数数组 arr，请你从中找出并返回一个幸运数。\n\n如果数组中存在多个幸运数，只需返回 最大 的那个。\n如果数组中不含幸运数，则返回 -1 。\n */\n/**\n * 输出来所有的数，然后排序，倒序检测\n * key === value\n * @param {number[]} arr\n * @return {number}\n */\nvar findLucky = function(arr) {\n    let list = [];\n    list.length = 500;\n    list.fill(0);\n    for(let e of arr) {\n        list[e] += 1;\n    }\n    for(let i = list.length - 1; i > 0; i--){\n        if(list[i] === i) return i;\n    }\n\n    return -1;\n};\nexport default {\n    func: () => {\n        const n = [1,1,2,2,3,3];\n        let res = findLucky(n);\n        console.log(res);\n\n        return `5368. 找出数组中的幸运数： ${res}`\n    },\n    title: '5368. 找出数组中的幸运数',\n    file: \"leetcode_js/findLucky.js\",\n    leetLink: 'https://leetcode-cn.com/problems/find-lucky-integer-in-an-array/solution/js-bian-li-by-egerton-2/'\n}","/**\n * 5369. 统计作战单位数\n * n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。\n\n每 3 个士兵可以组成一个作战单位，分组规则如下：\n\n从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k]\n作战单位需满足： rating[i] < rating[j] < rating[k] 或者 rating[i] > rating[j] > rating[k] ，其中  0 <= i < j < k < n\n请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。\n */\n/**\n * 遍历一遍，i,j,k count\n * 满足 i > j > k 同时 rating[i] > rating[j] > rating[k]\n * 或者相反的情况 count ++\n * i范围 0 ~ len - 3, j: i + 1 ~ len - 2 k:j + 1 ~ len - 1\n * \n * @param {number[]} rating\n * @return {number}\n */\nvar numTeams = function (rating) {\n    let count = 0;\n    const len = rating.length;\n    if (len < 3) return count;\n\n    for (let i = 0; i < len - 2; i++) {\n        for (let j = i + 1; j < len - 1; j++) {\n            for (let k = j + 1; k < len; k++) {\n                if (rating[i] > rating[j] && rating[j] > rating[k] || rating[i] < rating[j] \n                    && rating[j] < rating[k]) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n};\n\nconst title = \"5369. 统计作战单位数\"\nexport default {\n    func: () => {\n        const n = [1, 2, 3, 4, 5];\n        let res = numTeams(n);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/findLucky.js\",\n    leetLink: 'https://leetcode-cn.com/problems/count-number-of-teams/solution/bao-li-bian-li-by-egerton/'\n}","/**\n * 1162. 地图分析\n * 你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。\n\n我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。\n\n如果我们的地图上只有陆地或者海洋，请返回 -1。\n */\n/**\n * 创建一个新的地图，标出来地图上所有点到陆地的距离，如果本身是陆地0，海洋maxNumber\n * 给所有的点+1，向四周扩展，如果小于原来的举例，则替换\n * 重复这一步，len * 2次，所有的海洋都被覆盖\n * 返回最大值\n * \n * @param {number[][]} grid\n * @return {number}\n */\nvar maxDistance = function (grid) {\n    let max = 0;\n    const len = grid.length;\n    let dist = [];\n    dist.length = len;\n    //init\n    for (let i = 0; i < len; i++) {\n        dist[i] = [];\n        dist[i].length = len;\n        for (let j = 0; j < len; j++) {\n            dist[i][j] = grid[i][j] === 1 ? 0 : Number.MAX_SAFE_INTEGER;\n        }\n    }\n\n\n    for (let i = 0; i <= len * 2; i++) {\n        extend(i);\n    }\n\n    for (let i = 0; i < len; i++) {\n        for (let j = 0; j < len; j++) {\n            max = Math.max(dist[i][j], max);\n        }\n    }\n    if(max === Number.MAX_SAFE_INTEGER || max === 0) return -1;\n    else return max;\n\n    //距离 + 1\n    //给距离陆地扩展\n    function extend(n) {\n        // const maxDist = len * 2;\n        for (let i = 0; i < len; i++) {\n            for (let j = 0; j < len; j++) {\n                if (dist[i][j] === n) {\n                    let newDist = dist[i][j] + 1;\n                    //右\n                    if (i < len - 1) {\n                        dist[i + 1][j] = Math.min(dist[i + 1][j], newDist);\n                    }\n                    //左\n                    if (i > 0) {\n                        dist[i - 1][j] = Math.min(dist[i - 1][j], newDist);\n                    }\n                    //上\n                    if (j > 0) {\n                        dist[i][j - 1] = Math.min(dist[i][j - 1], newDist);\n                    }\n                    //下\n                    if (j < len - 1) {\n                        dist[i][j + 1] = Math.min(dist[i][j + 1], newDist);\n                    }\n                }\n            }\n        }\n    }\n};\n\nconst title = \"1162. 地图分析\"\nexport default {\n    func: () => {\n        const n = [[1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]];\n        let res = maxDistance(n);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/maxDistance.js\",\n    leetLink: \"https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/gou-jian-ju-chi-di-tu-dong-tai-gui-hua-by-egerton/\"\n}","/**\n * 面试题62. 最后的数字\n * 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n */\n/**\n * 试了几次，没有找到规律\n * 暴力法\n * 创建一个 0 ~ n -1的数组\n * 算出下标 t = (cur - 1 + m)%length\n * 每次splice(t, 1)\n * 直到length === 1\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nvar lastRemaining = function (n, m) {\n    let list = [];\n    for(let i = 0; i < n; i++) {\n        list[i] = i;\n    }\n\n    let cur = 0;\n    while(list.length > 1) {\n        cur = (cur - 1 + m)%list.length;\n        list.splice(cur, 1);\n    }\n\n    return list[0];\n};\n\nconst title = \"面62. 最后的数字\"\nexport default {\n    func: () => {\n        const n = 10;\n        const m = 17;\n        let res = lastRemaining(n, m);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/lastRemaining.js\",\n    leetLink: 'https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/bao-li-js-by-egerton/'\n}","/**\n * 912. 排序数组\n * 给你一个整数数组 nums，请你将该数组升序排列。\n */\n/**\n * 冒泡排序\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function (nums) {\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = nums.length - 1; j > i; j--) {\n            if (nums[j] < nums[j - 1]) {\n                swap(nums, j, j - 1);\n            }\n        }\n    }\n    return nums;\n};\n\n/**\n * 选择排序\n * @param {number[]} nums \n * @returns {number[]}\n */\nvar sortArray2 = function (nums) {\n    for (let i = 0; i < nums.length; i++) {\n        let sm = i;\n        for (let j = i; j < nums.length; j++) {\n            if (nums[j] < nums[sm]) {\n                sm = j;\n            }\n        }\n        swap(nums, sm, i);\n    }\n    return nums;\n};\n/**\n * 快速排序\n * \n * @param {number[]} nums \n * @returns {number[]}\n */\nvar sortArray3 = function (nums) {\n    quickSort(0, nums.length - 1);\n    return nums;\n    function quickSort(a, b) {\n        let m = divide(a, b);\n        if (m > a) {\n            quickSort(a, m - 1);\n        }\n\n        if (m < b) {\n            quickSort(m + 1, b);\n        }\n    }\n\n    /**\n     * 对nums的i - j 快速排序\n     * @param {number} i \n     * @param {number} j \n     * @returns {number} middle\n     */\n    function divide(a, b) {\n        let v = nums[a];\n        let i = a;\n        let j = b;\n        while (i < j) {\n            while (i <= j && nums[i] <= v) {\n                i++;\n            }\n            while (i <= j && nums[j] > v) {\n                j--;\n            }\n            if (i >= j) break;\n            swap(nums, i, j);\n        }\n        swap(nums, j, a);\n        return j;\n    }\n};\n\nfunction swap(list, i, j) {\n    const temp = list[j];\n    list[j] = list[i];\n    list[i] = temp;\n}\n\nconst title = \"912. 排序数组\"\nexport default {\n    func: () => {\n        const n = [0, 5, 9, 12, 2, 5, 7, 3, 8, 5]\n        let res = sortArray3(n);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/sortArray.js\",\n    leetLink: 'https://leetcode-cn.com/problems/sort-an-array/solution/kuai-pai-kan-zhao-jian-dan-xie-qi-lai-nan-by-egert/'\n}","/**\n * 1111. 有效括号的嵌套深度\n * 题目很难理解，贴上链接\n * https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/\n * \n */\n/**\n * 先计算seq的最大深度，那么分解的两个子字符串深度都为(偶数) deep/2，或者(奇数)deep/2 + 1, deep/2\n * 设两个栈，a,b,为他们的深度，令其不能超过自己的最大深度，amax, bmax依次分解原数组，规则如下\n * 如果遇到( 优先分配到a中，a++ 如果a深度=amax，则分配给b\n * 如果遇到)，如果b > 0，分配给b，b深度--,如果b === 0, 分配给a, a--\n * 直到最后 返回res\n * @param {string} seq\n * @return {number[]}\n */\nvar maxDepthAfterSplit = function (seq) {\n    let res = [];\n    const max = findMaxDeep(seq);\n\n    const amax = Math.ceil(max / 2);\n    const bmax = Math.floor(max / 2);\n    let a = 0;\n    let b = 0;\n\n    for(let s of seq) {\n        if(s === '(') {\n            if(a < amax) {\n                a++;\n                res.push(0);\n            } else {\n                b++;\n                res.push(1);\n            }\n        } else {\n            if(b > 0) {\n                b--;\n                res.push(1);\n            } else {\n                a--;\n                res.push(0);\n            }\n        }\n    }\n\n    return res;\n};\n\n/**\n * 默认str为有效括号字符串\n * @param {string} str \n */\nfunction findMaxDeep(str) {\n    let max = 0;\n    let n = 0;\n    for (let s of str) {\n        if (s === '(') {\n            n++;\n            max = Math.max(max, n);\n        } else {\n            n--;\n        }\n    }\n    return max;\n}\n\nconst title = \"1111. 有效括号的嵌套深度\"\nexport default {\n    func: () => {\n        const n = '()(())()';\n        let res = maxDepthAfterSplit(n);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/maxDepthAfterSplit.js\",\n    leetLink: 'https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution/jian-dan-rong-yi-li-jie-de-on-by-egerton/'\n}","/**\n * 289. 生命游戏\n * 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n\n如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；\n如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；\n如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；\n如果死细胞周围正好有三个活细胞，则该位置死细胞复活；\n根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。\n */\n/**\n * @param {number[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar gameOfLife = function(board) {\n    let copy = [];\n    for(let i = 0; i < board.length; i++) {\n        copy[i] = [];\n        for(let j = 0; j < board[i].length; j++) {\n            copy[i][j] = board[i][j];\n        }\n    }\n\n    for(let i = 0; i < board.length; i++) {\n        for(let j = 0; j < board[i].length; j++) {\n            let num = count(copy, i, j);\n            if(num === 3) {\n                board[i][j] = 1;\n            } else if(num === 2 && copy[i][j] === 1) {\n                board[i][j] = 1;\n            } else {\n                board[i][j] = 0;\n            }\n        }\n    }\n};\n\nfunction count(board, i, j) {\n    let num = 0;\n    for(let x = i - 1; x <= i + 1; x++) {\n        for(let y = j - 1; y <= j + 1; y++) {\n            if(typeof board[x] === 'object' && board[x][y] === 1) num++;\n        }\n    }\n    if(board[i][j] === 1) num--;\n    return num;\n}\n\nconst title = \"289. 生命游戏\"\nexport default {\n    func: () => {\n        const board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]];\n        gameOfLife(board);\n        console.log(board);\n\n        return `${title}: ${board}`\n    },\n    title: title,\n    file: \"leetcode_js/gameOfLife.js\",\n}","/**\n * 面试题 01.07. 旋转矩阵\n * 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。\n    不占用额外内存空间能否做到？\n */\n/**\n * 在研究x,y的坐标变化时，发现可以通过在原数组，对角线反转，在中线左右反转即可\n * 时间复杂度 O(n^2) 空间复杂度O(1)\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function(matrix) {\n    const n = matrix.length;\n    //对角线反转 0,0  n-1,n-1\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < i; j++) {\n            swap(matrix, [i, j], [j, i]);\n        }\n    }\n\n    //中线左右反转\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < n / 2; j++) {\n            swap(matrix, [i, j], [i, n - 1 - j]);\n        }\n    }\n\n    function swap(matrix, [x1, y1], [x2, y2]) {\n        const tmp = matrix[x1][y1];\n        matrix[x1][y1] = matrix[x2][y2];\n        matrix[x2][y2] = tmp;\n    }\n};\n\nconst title = \"01.07. 旋转矩阵\"\nexport default {\n    func: () => {\n        let matrix = \n        [\n          [1,2,3],\n          [4,5,6],\n          [7,8,9]\n        ];\n        rotate(matrix);\n        console.log(matrix);\n\n        return `${title}: ${matrix}`\n    },\n    title: title,\n    file: \"leetcode_js/rotate.js\",\n    leetLink: 'https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/jian-dan-hao-li-jie-de-kong-jian-o1-by-egerton/'\n}","/**\n * 42. 接雨水\n * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n */\n/**\n * 找出最大值maxIndex\n * 维护一个res\n * 遍历左侧到max, 维护当前数字，向右侧补全。同样遍历右侧\n * target - height数组得到结果\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    let res = 0;\n    let maxIndex = 0;\n    for(let i = 0; i < height.length; i++) {\n        if(height[i] > height[maxIndex]) {\n            maxIndex = i;\n        }\n    }\n\n    let curr = 0;\n    //左侧\n    for(let i = 0; i < maxIndex; i++) {\n        if(height[i] > curr) {\n            curr = height[i];\n        } else {\n            res += curr - height[i];\n        }\n    }\n\n    //right\n    curr = 0;\n    for(let i = height.length - 1; i > maxIndex; i--) {\n        if(height[i] > curr) {\n            curr = height[i];\n        } else {\n            res += curr - height[i];\n        }\n    }\n\n    return res;\n};\n\nconst title = \"42. 接雨水\"\nexport default {\n    func: () => {\n        const list = [0,1,0,2,1,0,1,3,2,1,2,1];\n        const res = trap(list);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/trap.js\",\n    leetLink: 'https://leetcode-cn.com/problems/trapping-rain-water/solution/onbian-li-by-egerton/'\n}","/**\n * 460. LFU缓存\n */\n/**\n * @param {number} capacity\n */\nvar LFUCache = function (capacity) {\n    this.map = new Map();\n    this.capa = capacity;\n    this.timer = 0;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function (key) {\n    let res = this.map.get(key);\n    if (res === undefined) return -1;\n    res.times = res.times + 1;\n    res.lastDate = this.timer++;\n    return res.value;\n};\n\n/** \n * value, times, lastDate\n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function (key, value) {\n    if(this.capa === 0) return ;\n\n    if (this.map.has(key)) {\n        const old = this.map.get(key);\n        this.map.set(key, {\n            value: value,\n            times: old.times + 1,\n            lastDate: this.timer++\n        });\n    } else {\n        if (this.map.size < this.capa) {\n            this.map.set(key, {\n                value: value,\n                times: 1,\n                lastDate: this.timer++\n            });\n        } else {\n            //delete small oldest\n            let smallest = {\n                times: Number.MAX_SAFE_INTEGER,\n                lastDate: this.timer++\n            };\n            let smallestKey;\n\n            for (let e of this.map) {\n                let obj = e[1];\n                if (obj.times < smallest.times || obj.times === smallest.times && obj.lastDate < smallest.lastDate) {\n                    smallest = e[1];\n                    smallestKey = e[0];\n                }\n            }\n            this.map.delete(smallestKey);\n\n            //add new\n            this.map.set(key, {\n                value: value,\n                times: 1,\n                lastDate: this.timer++\n            });\n        }\n    }\n};\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * var obj = new LFUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n\nconst title = \"460. LFU缓存\";\nexport default {\n    func: () => {\n\n        let cache = new LFUCache(2 /* capacity (缓存容量) */);\n        let out;\n        cache.put(1, 1);\n        cache.put(2, 2);\n        cache.put(3, 3);\n        cache.get(3);\n        cache.get(2);\n        cache.put(4, 4);\n        out = cache.get(2);       // 返回 1\n\n        console.log(cache);\n\n        return `${title}: ${JSON.stringify(cache)}`\n    },\n    title: title,\n    file: \"leetcode_js/LFUCache.js\",\n}","/**\n * 面试题13. 机器人的运动范围\n */\n/**\n * 用动态规划，创建一个m x n的数组，从0 ,0 开始向右 向下扩展，填充true, false\n * \n * @param {number} m\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar movingCount = function(m, n, k) {\n    let list = [];\n    for(let i = 0; i < m; i++) {\n        list[i] = [];\n    }\n    list[0][0] = true;\n    for(let i = 0; i < m; i++) {\n        for(let j = 0; j < n; j++) {\n            if(list[i][j] === true) {\n                //向右向下扩展\n                if(i + 1 < m) {\n                    list[i + 1][j] = judge(i + 1, j, k);\n                }\n\n                if(j + 1 < n) {\n                    list[i][j + 1] = judge(i, j + 1, k);\n                }\n            }\n        }\n    }\n    return flatten(list).filter(e => e).length;\n};\n\nfunction flatten(array) {\n    return array.reduce(\n        (acc, val) => acc.concat(Array.isArray(val) ? flatten(val) : val),\n        [])\n}\n\nfunction judge(x, y, k) {\n    let v = 0;\n    v += Math.floor(x / 100) + Math.floor(x / 10) + x % 10;\n    v += Math.floor(y / 100) + Math.floor(y / 10) + y % 10;\n    return v <= k;\n}\n\nconst title = \"13. 机器人的运动范围\"\nexport default {\n    func: () => {\n        let res = movingCount(38, 15, 9);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/movingCount.js\",\n}","/**\n * 22. 括号生成\n * 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n */\n/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function (n) {\n    let cache = [];\n\n    return generate(n);\n\n    function generate(n) {\n        if (cache[n]) return cache[n];\n\n        let res = [];\n        if (n === 0) return [''];\n\n\n\n        //(a)b  对a b的个数进行分组\n        for (let i = 0; i < n; i++) {\n            for (let a of generate(i)) {\n                for (let b of generate(n - i - 1)) {\n                    res.push(`(${a})${b}`);\n                }\n            }\n        }\n\n        cache[n] = res;\n        return res;\n    }\n};\n\nconst title = \"22. 括号生成\"\nexport default {\n    func: () => {\n        let res = generateParenthesis(4);\n        console.log(res);\n\n        return `${title}: length${res.length} ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/generateParenthesis.js\",\n}","/**\n * 445. 两数相加 II\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * 把两个linkedlist 转换为栈，倒叙计算，生成新的linkedList\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n    let stack1 = [];\n    let stack2 = [];\n\n    while(l1) {\n        stack1.push(l1.val);\n        l1 = l1.next;\n    }\n    while(l2) {\n        stack2.push(l2.val);\n        l2 = l2.next;\n    }\n\n    const len1 = stack1.length;\n    const len2 = stack2.length;\n    let pre = new ListNode();\n    for(let i = 1, add = 0, len = Math.max(len1, len2);i <= len || add === 1; i++ ) {\n        const a = stack1.length > 0? stack1.pop() : 0;\n        const b = stack2.length > 0? stack2.pop() : 0;\n\n        const num = a + b + add;\n        add = num >= 10 ? 1 : 0;\n        let tmp = new ListNode(num % 10);\n        tmp.next = pre.next;\n        pre.next = tmp;\n    }\n    return pre.next;\n};\n\n\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nlet h1 = new ListNode(1);\n\nlet h2 = new ListNode(9);\nh2.next = new ListNode(9);\n\nconst title = \"445. 两数相加 II\"\nexport default {\n    func: () => {\n        const res = addTwoNumbers(h1, h2);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/addTwoNumbers.js\",\n    leetLink: 'https://leetcode-cn.com/problems/add-two-numbers-ii/solution/zhan-dao-xu-by-egerton/'\n}","/**\n * 45. 跳跃游戏 IIZ\n */\n/**\n * 判断一个值能否调到最后 i + nums[i] === nums.length - 1\n * 递归的方法，会报内存泄漏\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function (nums) {\n    if (nums.length === 1) return 0;\n\n    for (let i = 0; i < nums.length; i++) {\n        if (i + nums[i] >= nums.length - 1) {\n            return jump(nums.slice(0, i + 1)) + 1;\n        }\n    }\n\n    return Infinity;\n};\n\n/**\n * 动态规划，改进效率\n * 辅助数组，记录到节点的最小步数\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function (nums) {\n    let minStep = [];\n    minStep.length = nums.length;\n    minStep.fill(Infinity);\n    minStep[0] = 0;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = 0; j < nums[i]; j++) {\n            let target = i + j + 1;\n            if (target < nums.length - 1) {\n                minStep[target] = Math.min(minStep[i] + 1, minStep[target]);\n            } else if(target === nums.length - 1) {\n                return minStep[i] + 1\n            }\n\n        }\n    }\n\n    return minStep[nums.length - 1];\n};\n\n/**\n * O(n)\n * @param {*} nums \n */\nvar jump = function (nums) {\n    let len = nums.length;\n    let end = 0;\n    let steps = 0;\n    let maxPos = 0;\n    for(let i = 0; i < len - 1; i++) {\n        maxPos = Math.max(maxPos, i + nums[i]);\n\n        if(end === i) {\n            steps ++;\n            end = maxPos;\n        }\n    }\n    return steps;\n};\n\nexport default {\n    func: () => {\n        const n = [2, 3, 1, 1, 4];\n        let res = jump(n);\n        console.log(res);\n\n        return `${res}`;\n    },\n    title: \"45. 跳跃游戏 IIZ\",\n    file: \"leetcode_js/jump.js\",\n};\n","import isValidBST from \"../leetcode_js/isValidBST\";\nimport longestPalindrome2 from \"../leetcode_js/longestPalindrome2\";\nimport maxDepth from \"../leetcode_js/maxDepth\";\nimport isRectangleOverlap from \"../leetcode_js/isRectangleOverlap\";\nimport countChars from \"../leetcode_js/countChars\";\nimport compressString from \"../leetcode_js/compressString\";\nimport majorityElement from \"../leetcode_js/majorityElement\";\nimport gcdOfStrings from \"../leetcode_js/gcdOfStrings\";\nimport canThreePartsEqualSum from \"../leetcode_js/canThreePartsEqualSum\";\nimport isSameTree from \"../leetcode_js/isSameTree\";\nimport candies2 from \"../leetcode_js/candies2\";\nimport findContinuousSequence from \"../leetcode_js/findContinuousSequence\";\nimport preorderTraversal from \"../leetcode_js/preorderTraversal\";\nimport atoi from \"../leetcode_js/myAtoi\";\nimport flatten from \"../leetcode_js/flatten\";\nimport longestPalindrome from \"../leetcode_js/longestPalindrome\";\nimport reverseLinkedList from \"../leetcode_js/reverseLinkedList\";\nimport mirrorTree from \"../leetcode_js/mirrorTree\";\nimport maxProfit from \"../leetcode_js/maxProfit\";\nimport diameterOfBinaryTree from \"../leetcode_js/diameterOfBinaryTree\";\nimport getLeastNumbers from \"../leetcode_js/getLeastNumbers\";\nimport canMeasureWater from \"../leetcode_js/canMeasureWater\";\nimport middleNode from \"../leetcode_js/middleNode\";\nimport invertTree from \"../leetcode_js/invertTree\";\nimport surfaceArea from \"../leetcode_js/surfaceArea\";\nimport numRookCaptures from \"../leetcode_js/numRookCaptures\";\nimport numTrees from \"../leetcode_js/numTrees\";\nimport hasGroupsSizeX from \"../leetcode_js/hasGroupsSizeX\";\nimport minimumLengthEncoding from \"../leetcode_js/minimumLengthEncoding\";\nimport findLucky from \"../leetcode_js/findLucky\";\nimport numTeams from \"../leetcode_js/numTeams\";\nimport maxDistance from \"../leetcode_js/maxDistance\";\nimport lastRemaining from \"../leetcode_js/lastRemaining\";\nimport sortArray from \"../leetcode_js/sortArray\";\nimport maxDepthAfterSplit from \"../leetcode_js/maxDepthAfterSplit\";\nimport gameOfLife from \"../leetcode_js/gameOfLife\";\nimport rotate from \"../leetcode_js/rotate\";\nimport trap from \"../leetcode_js/trap\";\nimport LFUCache from \"../leetcode_js/LFUCache\";\nimport movingCount from \"../leetcode_js/movingCount\";\nimport generateParenthesis from \"../leetcode_js/generateParenthesis\";\nimport superEggDrop from \"../leetcode_js/superEggDrop\";\nimport addTwoNumbers from \"../leetcode_js/addTwoNumbers\";\nimport reversePairs from \"../leetcode_js/reversePairs\";\nimport mergeArray from \"../leetcode_js/mergeArray\";\nimport lengthOfLongestSubstring from \"../leetcode_js/lengthOfLongestSubstring\";\nimport maxSubArray from \"../leetcode_js/maxSubArray\";\nimport jump from \"../leetcode_js/jump\";\nimport mySqrt from \"../leetcode_js/mySqrt\";\n\nlet list = [\n    mySqrt,\n    flatten,\n    atoi,\n    longestPalindrome,\n    reverseLinkedList,\n    mirrorTree,\n    maxProfit,\n    diameterOfBinaryTree,\n    preorderTraversal,\n    findContinuousSequence,\n    candies2,\n    isSameTree,\n    canThreePartsEqualSum,\n    gcdOfStrings,\n    majorityElement,\n    compressString,\n    countChars,\n    isRectangleOverlap,\n    maxDepth,\n    longestPalindrome2,\n    isValidBST,\n    getLeastNumbers,\n    canMeasureWater,\n    middleNode,\n    invertTree,\n    surfaceArea,\n    numRookCaptures,\n    numTrees,\n    hasGroupsSizeX,\n    minimumLengthEncoding,\n    findLucky,\n    numTeams,\n    maxDistance,\n    lastRemaining,\n    sortArray,\n    maxDepthAfterSplit,\n    gameOfLife,\n    trap,\n    LFUCache,\n    rotate,\n    movingCount,\n    generateParenthesis,\n    addTwoNumbers,\n    reversePairs,\n    mergeArray,\n    lengthOfLongestSubstring,\n    maxSubArray,\n    jump,\n];\n\nexport default list;\n","/**\n * 69. x 的平方根\n */\n/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function (x) {\n    let left = 0;\n    let right = x;\n    let ans = -1;\n\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (mid * mid <= x) {\n            left = mid + 1;\n            ans = mid;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return ans;\n};\n\nconst title = \"69. x 的平方根\";\nexport default {\n    func: () => {\n        const res = mySqrt(16);\n        console.log(res);\n\n        return `${title}: ${res}`;\n    },\n    title: title,\n    file: \"leetcode_js/mySqrt.js\",\n};\n","/**\n * 面试题51. 数组中的逆序对\n*/\n/**\n * 暴力，每个元素，跟后面的每个元素比较一遍\n * 暴力法超时，需要归并排序思想解题\n * O(n^2)\n * @param {number[]} nums\n * @return {number}\n */\nvar reversePairs = function(nums) {\n    let res = 0;\n    for(let i = 0; i < nums.length; i++) {\n        for(let j = i; j < nums.length; j++) {\n            if(nums[j] < nums[i]) {\n                res++;\n            }\n        }\n    }\n\n    return res;\n};\n\nconst title = \"51. 数组中的逆序对\"\nexport default {\n    func: () => {\n        const n = [7,5,6,4];\n        let res = reversePairs(n);\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/reversePairs.js\",\n}","/**\n * 面试题 10.01. 合并排序的数组\n */\n/**\n * 定义一个a数组存储A的前m个元素\n * 对两个数组，进行合并，进入A\n * 每次判断第一个元素，把小的放进去\n * @param {number[]} A\n * @param {number} m\n * @param {number[]} B\n * @param {number} n\n * @return {void} Do not return anything, modify A in-place instead.\n */\nvar mergeArray = function (A, m, B, n) {\n    let a = A.slice(0, m);\n\n    let i = 0;\n    while(a.length > 0 || B.length > 0) {\n        if(a[0] < B[0] || B.length === 0) {\n            A[i] = a.shift();\n        } else {\n            A[i] = B.shift();\n        }\n\n        i++;\n    }\n};\n\nconst title = \"10.01. 合并排序的数组\";\nexport default {\n    func: () => {\n        let A = [1, 2, 3, 0, 0, 0];\n        let m = 3;\n        let B = [2, 5, 6];  \n        let n = 3;\n\n        mergeArray(A, m, B, n);\n        console.log(A);\n\n        return `${title}: ${A}`;\n    },\n    title: title,\n    file: \"leetcode_js/mergeArray.js\",\n};\n","/**\n * 3. 无重复字符的最长子串\n * 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n */\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let maxLen = 0;\n\n    let valid = new Set();\n    let end = 0;\n    // debugger\n    for(let start = 0; start < s.length; start++) {\n        valid.delete(s.charAt(start - 1));\n\n        while(end < s.length && !valid.has(s.charAt(end))) {\n            valid.add(s.charAt(end));\n            end++;\n        }\n\n        maxLen = Math.max(maxLen, valid.size);\n    }\n\n    return maxLen;\n};\n\nconst title = \"3. 无重复字符的最长子串\";\n\nexport default {\n    func: () => {\n        let matrix = 'bbbb'\n        let res = lengthOfLongestSubstring(matrix)\n        console.log(res);\n\n        return `${title}: ${res}`\n    },\n    title: title,\n    file: \"leetcode_js/lengthOfLongestSubstring.js\",\n    leetLink: 'https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/js-setguan-fang-ti-jie-er-lai-by-egerton/'\n}","/**\n * 53. 最大子序和\n * https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/\n */\n/**\n * 暴力法做出来\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n    let max = nums[0];\n    for (let i = 0; i < nums.length; i++) {\n        let iCurrent = 0;\n        for (let j = i; j < nums.length; j++) {\n            iCurrent += nums[j];\n            max = Math.max(max, iCurrent);\n        }\n    }\n\n    return max;\n};\n\n/**\n * 如果之前的和为正则相加, 为负则丢弃之前的和\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n    for (let i = 0; i < nums.length; i++) {\n        if (i > 0 && nums[i - 1] > 0) {\n            nums[i] = nums[i] + nums[i - 1];\n        }\n    }\n    return Math.max(...nums);\n};\n\nexport default {\n    func: () => {\n        const n = [-2, -1, -3, -4];\n        // const n = [-2,1,-3,4,-1,2,1,-5,4];\n        let res = maxSubArray(n);\n\n        return `maxSubArray ${n}： ${res}`;\n    },\n    title: \"53. 最大子序和\",\n    file: \"leetcode_js/maxSubArray.js\",\n    leetLink:\n        \"https://leetcode-cn.com/problems/maximum-subarray/solution/kan-liao-ti-jie-zhong-xie-de-dong-tai-gui-hua-by-e/\",\n};\n","import React, { useState, useEffect, useRef } from \"react\";\nimport \"./style.sass\";\nimport leetcodeList from \"../leetcode_js/index\";\nimport shortid from \"shortid\";\n\nconst urlPrefix = \"https://github.com/andycao/algorithmLearn/blob/master/src/\";\nfunction TaskList(props) {\n    //展示结果的index\n    const [stageIndex, setStageIndex] = useState();\n    const isFirstRun = useRef(true);\n    const [list, setList] = useState(\n        leetcodeList\n            .map((entry) => {\n                return {\n                    ...entry,\n                    key: shortid.generate(),\n                };\n            })\n            .sort((a, b) => {\n                const reg = /\\d+/;\n                let ares = a.title.match(reg) || 0;\n                let bres = b.title.match(reg) || 0;\n                return ares - bres;\n            })\n    );\n\n    useEffect(() => {\n        if (isFirstRun.current) {\n            isFirstRun.current = false;\n            return;\n        }\n\n        setList([...list].reverse());\n        setStageIndex(null);\n    }, [props.order]);\n\n    return (\n        <>\n            <ul>\n                {list.map((entry, index) => {\n                    return (\n                        <Quest\n                            key={index}\n                            answer={entry}\n                            showAns={stageIndex === index}\n                            stageSelf={setStageIndex.bind(null, index)}\n                        ></Quest>\n                    );\n                })}\n            </ul>\n        </>\n    );\n}\n\nfunction Quest(props) {\n    const { answer, stageSelf, showAns } = props;\n    const [result, setResult] = useState(\"\");\n\n    return (\n        <li>\n            <div className=\"action\">\n                <span>{answer.title}</span>\n                <span\n                    className=\"link\"\n                    onClick={() => {\n                        window.open(urlPrefix + answer.file);\n                    }}\n                >\n                    源码\n                </span>\n                <span\n                    className=\"link\"\n                    onClick={(e) => {\n                        e.preventDefault();\n                        stageSelf();\n                        setResult(answer.func());\n                    }}\n                >\n                    运行\n                </span>\n                {answer.leetLink ? (\n                    <span\n                        className=\"link\"\n                        onClick={() => {\n                            window.open(answer.leetLink);\n                        }}\n                    >\n                        leetcode题解\n                    </span>\n                ) : null}\n            </div>\n            {showAns ? <div className=\"result\">{result}</div> : \"\"}\n        </li>\n    );\n}\n\nexport default TaskList;\n","import React, { useState, useEffect } from \"react\";\nimport Header from \"./pages/header\";\nimport TaskList from \"./pages/list\";\n\nfunction App() {\n    //0 正序， 1 倒序\n    let [order, setOrder] = useState(0);\n    useEffect(() => {\n        document.title = \"Andy的算法学习\";\n    }, []);\n\n    return (\n        <div className=\"container\">\n            <Header\n                changeOrder={() => {\n                    order === 0 ? setOrder(1) : setOrder(0);\n                }}\n            />\n            <TaskList order={order} />\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}